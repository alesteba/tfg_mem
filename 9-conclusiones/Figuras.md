Figura 1 - Imagen del frontend de la aplicación en la que se muestran, mediante un mapeo con colores, la evolución de los índices vegetativos en varias parcelas agrícolas.

Figura 2 - Esquema ciclo iterativo en cascada.

Figura 3 - Diagrama Gantt con un desglose estipulado de la evolución del proyecto.

Figura 4 - Captura del visor web en la que se aprecia cómo se monitorizan varias parcelas.

Figura 5 - Esquema de las etapas de desarrollo planificadas para el trabajo.

Figura 6 - Ejemplo de uso de una migración en Django al estado inicial de la base de datos.

Figura 7 - Ejecución del pipeline mientras realiza la descarga de datos del satélite Copernicus.

Figura 8 - Esquema relacional en uso de la aplicación

Figura 9 - Esquema relacional inicial de partida, con entidades definidas, pero sin implementar, se toma como idea para el comienzo del diseño.

Figura 10 - Modelo relacional de las entidades descritas para su mejor comprensión.

Figura 11 - Pipeline design pattern, diagrama de clases para exponer cómo vamos a utilizar los bloques de carga creamos.

Figura 12 - Estados ordenados del pipeline que queremos implementar.

Figura 13 - Imagen satelital con nubes para indicar cómo afectan a los índices vegetativos calculados en la vista minable.

Figura 14 - Ejecución del pipeline implementado desde la herramienta de integración continua Jenkins.

Figura 15 - Tabla con la vista minable calculada para un rango de fechas concretas.

Figura 16 - Comparación de los algoritmos. Valores reales vs. los predichos por cada uno de los algoritmos utilizados.

Figura 17 - Predicción de la cantidad de Kg de cultivo que se va a cosechar. Resultado tras la ejecución del último 'stage' en el pipeline.

Figura 18 - Imagen del grafo asociado a las notas en las que se ha escrito esta memoria.

Figura 19 - Resumen del pipeline implementado a lo largo de este trabajo.

Figura 20 - Ejemplo construcción de la memoria desde Github Actions.

Figura 21 - Captura de la ejecución del pipeline tras terminar la ejecución por completo.



