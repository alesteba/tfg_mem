

<!DOCTYPE html>

<html>

    <head>
        <meta charset="UTF-8">
        <title>TFG | Pipeline de Datos</title>

        <link rel="stylesheet" href="body.css">
        <link rel="stylesheet" href="style.css">
        <link rel="stylesheet" href="codehilite.css">
        <link rel="stylesheet" media="print" href="print.css" />
        
    </head> 

    <body>

        <div class="content">

            <h2>ÍNDICE</h2>

            <ul><li><a href="#RESUMEN">1 RESUMEN</a></li><li><a href="#ABSTRACT">2 ABSTRACT</a></li><li><a href="#INTRODUCCIÓN">3 INTRODUCCIÓN</a></li><ul><li><a href="#Contexto">3.1 Contexto</a></li><li><a href="#Previos">3.2 Previos</a></li></ul><li><a href="#PLANIFICACIÓN">4 PLANIFICACIÓN</a></li><ul><li><a href="#Alcance">4.1 Alcance</a></li><li><a href="#Metodología">4.2 Metodología</a></li><li><a href="#EDT">4.3 EDT</a></li><li><a href="#Entregables">4.4 Entregables</a></li><li><a href="#Gantt">4.5 Gantt</a></li><li><a href="#Comunicaciones">4.6 Comunicaciones</a></li><li><a href="#Riesgos">4.7 Riesgos</a></li></ul><li><a href="#ANÁLISIS">5 ANÁLISIS</a></li><ul><li><a href="#Dominio_agronómico">5.1 Dominio agronómico</a></li><li><a href="#Fuentes_de_datos">5.2 Fuentes de datos</a></li><li><a href="#Automatizacion">5.3 Automatizacion</a></li><li><a href="#Tecnologías">5.4 Tecnologías</a></li><li><a href="#Requisitos">5.5 Requisitos</a></li></ul><li><a href="#INFRAESTRUCTURA">6 INFRAESTRUCTURA</a></li><ul><li><a href="#Arquitectura_física">6.1 Arquitectura física</a></li><li><a href="#Vagrant">6.2 Vagrant</a></li><li><a href="#Entorno">6.3 Entorno</a></li></ul><li><a href="#DISEÑO">7 DISEÑO</a></li><ul><li><a href="#Carga_de_datos">7.1 Carga de datos</a></li><li><a href="#Modelo_relacional">7.2 Modelo relacional</a></li><li><a href="#Servicios">7.3 Servicios</a></li></ul><li><a href="#PIPELINE">8 PIPELINE</a></li><ul><li><a href="#Transformación_de_datos">8.1 Transformación de datos</a></li><li><a href="#Design_pattern">8.2 Design pattern</a></li><li><a href="#Vista_minable">8.3 Vista minable</a></li><li><a href="#Integración_continua">8.4 Integración continua</a></li></ul><li><a href="#MODELO_IA">9 MODELO IA</a></li><ul><li><a href="#Preprocesamiento">9.1 Preprocesamiento</a></li><li><a href="#Regresión">9.2 Regresión</a></li><li><a href="#Mejor_modelo">9.3 Mejor modelo</a></li><li><a href="#Predicciones">9.4 Predicciones</a></li></ul><li><a href="#SEGUIMIENTO">10 SEGUIMIENTO</a></li><ul><li><a href="#Desviaciones">10.1 Desviaciones</a></li><li><a href="#Memoria">10.2 Memoria</a></li></ul><li><a href="#CONCLUSIONES">11 CONCLUSIONES</a></li><li><a href="#BIBILIOGRAFÍA">12 BIBILIOGRAFÍA</a></li></ul>

            <p style="page-break-after: always;">&nbsp;</p>

            <div id=RESUMEN><h2>1 RESUMEN</h2><p>El trabajo consistirá en la reestructuración de una aplicación de gestión de datos agronómicos. Estos datos, que actualmente provienen de varias fuentes, van a ser tratados en una nueva arquitectura que posibilitará técnicas de integración y despliegue continuo. En su diseño pasamos por las etapas sucesivas de infraestructura, diseño de un modelo relacional, utilización de un pipeline para la carga de datos y, finalmente, la obtención de una vista minable sobre la que se ejecutarán modelos de Inteligencia Artificial. Esta vista permitirá predecir mediante regresión la cantidad de kg de cultivo que se espera cosechar en una parcela y en una fecha determinadas.</p>
<p style="page-break-after: always;">&nbsp;</p></div><div id=ABSTRACT><h2>2 ABSTRACT</h2><p>The following work will handle the restructuring of an agronomic data management application. These data, which currently come from various sources, are going to be processed in a new architecture that will enable continuous integration and deployment techniques. In its design, we go through the successive stages of infrastructure, design of a relational model, use of a pipeline for data loading and, finally, obtaining a mineable view on which Artificial Intelligence models will be executed. This view will make it possible to predict, with a regression model, the amount of kilograms of crop that is expected to be harvested in a plot and on a given date.</p>
<p style="page-break-after: always;">&nbsp;</p></div><div id=INTRODUCCIÓN><h2>3 INTRODUCCIÓN</h2><div id=Contexto><h3>3.1 Contexto</h3><p>El propósito de este proyecto es mejorar el flujo de trabajo del equipo de "SpectralGeo" mediante la automatización del proceso de recogida y procesado de datos agronómicos que se utilizan en la creación de modelos de inteligencia artificial para el cultivo.</p>
<p>AGRAI es una aplicación para la gestión de cultivo que permite al agricultor monitorizar el estado de sus parcelas. El estado actual de la aplicación se centra el despliegue de datos agronómicos y vegetativos georreferenciados a través de en una interfaz web. Los usuarios de la aplicación, normalmente agricultores o cooperativas, pueden consultar el estado de su parcelario junto con algunas predicciones, como puede ser la cantidad de Kg que se van a cosechar en una fecha determinada. El acceso a dicha aplicación puede darse desde equipo de sobremesa o un dispositivo móvil, aunque es este último lo que parece que se utiliza más. </p>
<p>
<figure><img src="figures/visor_GIS_det.png" /><figcaption>Imagen del frontend de la aplicación en la que se muestran, mediante un mapeo con colores, la evolución de los índices vegetativos en varias parcelas agrícolas.</figcaption>
</figure>
</p>
<p>Actualmente, cómo se procesa la información que utiliza nuestra aplicación es un proceso tedioso para el equipo. En este proceso, diferentes miembros trabajan con tecnologías distintas sobre datos duplicados provenientes de fuentes comunes. Aunque se realiza una planificación y coordinación de los proyectos, se pierde bastante tiempo en la transformación de los datos que cada miembro del equipo necesita para llevar a cabo su labor.</p>
<p>El objetivo de este trabajo es mejorar y automatizar el flujo de trabajo del equipo, convirtiendo la aplicación AGRAI en una herramienta robusta que manipule un único repositorio de datos al cual el resto del equipo pueda acceder, utilizándolo de forma segura y -lo más importante,-sin duplicar y romper la integridad de estos datos.</p>
<p>Es un proyecto ambicioso debido a que no solo es importante el conocimiento técnico sino que serán necesarios cambios en la forma de trabajo del equipo, cambios que se basan en  la confianza de cada miembro en la nueva forma de trabajo que se desea implementar. </p></div><div id=Previos><h3>3.2 Previos</h3><p>SpectralGeo se ha especializado en el uso de nuevas tecnologías para sectores como el de la agricultura o el reciclaje, centrándose en proyectos con carácter reivindicativo de la sostenibilidad medioambiental. La relación con clientes como Ecoembes o el desarrollo de software para la gestión sostenible de cultivos lo demuestran.</p>
<p>Durante las prácticas realizas en la empresa se identificó que era totalmente necesario dotar de una arquitectura robusta a la aplicación AGRAI. En estas prácticas se comenzó el desarrollo de un modelo de datos sobre el que dicha aplicación pudiese escalarse posteriormente.</p>
<p>Actualmente, AGRAI aún necesita una reestructuración para la gestión de grandes volúmenes de datos agronómicos, poniendo especial énfasis en los índices vegetativos que gestiona, los cuales provienen del procesamiento de imágenes satelitales. El estado actual de dicha aplicación consiste en la monitorización de cultivos a través del análisis de históricos de datos.</p>
<p>La aplicación ya está creada; el cliente obtiene los resultados que espera cuando consulta el estado de su parcelario en la interfaz de la aplicación. Como equipo, nos organizamos para que la información y los modelos predictivos lleguen al cliente a través de esta, pero son varios los puntos en los que trabajamos en exceso para finalmente mostrar una "predicción" al cliente. </p>
<p>El valor más importante que predecimos es el número de kg que se espera cosechar en la fecha estipulada para el agricultor. Esta predicción hace uso de valores de índices vegetativos a partir de imágenes satelitales tomadas en diferentes fechas. El histórico de datos registrado permite estudiar la evolución del cultivo y, finalmente, mediante métodos de Inteligencia Artificial IA, predecir un valor en la fecha en la que se espera cosechar.</p>
<p>Serán las etapas de infraestructura, diseño, implementación y modelado las que buscaremos optimizar en el contexto de todo el equipo, debido a que estas etapas se reparten entre sus miembros.</p>
<p>Justificamos este cambio como parte de una búsqueda de procesos esbeltos (lean), que consisten en la eliminación de los "desperdicios", o fuentes de despilfarro de tiempo y trabajo en la elaboración de productos o servicios. A través de la solución que vamos a implantar buscamos la optimización continua del proceso y la aceptación de esta cultura de optimización por el equipo.</p>
<p>Los puntos más importantes de los procesos "lean" son los siguientes:</p>
<ul>
<li>identificar los desperdicios y tratar de eliminarlos</li>
<li>mejorar la comunicación interna de la organización</li>
<li>reducir costes y tiempos de entrega y mejorar la calidad</li>
</ul></div><p style="page-break-after: always;">&nbsp;</p><div id=PLANIFICACIÓN><h2>4 PLANIFICACIÓN</h2><div id=Alcance><h3>4.1 Alcance</h3><p>A continuación se expondrán los objetivos generales del proyecto para aportar una visión global del trabajo.</p>
<p>MODIFICAR _&gt;</p>
<ul>
<li>Automatizar el despliegue de la aplicación mediante infraestructura como código.</li>
<li>Preparar diferentes entornos con las tecnologías necesarias para cada parte de la aplicación.</li>
<li>Identificar los conceptos del dominio agronómico y de índices vegetativos susceptibles de ser implementados.</li>
<li>Diseñar un modelo de datos que permita un rápido escalado de dicha aplicación.</li>
<li>Orientar la BD para manejar grandes volúmenes de datos.</li>
<li>Automatizar el proceso de trasformación de los datos mediante el diseño de un pipeline.</li>
<li>Diseñar un algoritmo que exporte la vista minable necesaria para predecir la producción de un cultivo (kg).</li>
<li>Probar técnicas de Inteligencia Artificial para entrenar el mejor modelo de regresión para la producción anterior.</li>
<li>Utilizar el modelo de producción de cultivo para predecir nuevos valores que no han sido usados en el entrenamiento.</li>
<li>Incluir los resultados en la presentación de la aplicación.</li>
</ul></div><div id=Metodología><h3>4.2 Metodología</h3><p>En el equipo hacemos uso de SCRUM para la gestión del proyecto. Dicha metodología permite un desarrollo en cascada de las diferentes tareas propuestas para la creación del pipeline.</p>
<p>Se usará un ciclo de vida iterativo e incremental. Dentro de las fases del proyecto (también llamadas iteraciones), se repiten de manera intencionada una o más actividades del  proyecto. Con estas iteraciones el entendimiento del producto por parte del equipo va aumentando. Las fases (iteraciones) desarrollan el producto a través de una serie de ciclos repetidos, mientras que los incrementos van añadiendo sucesivamente funcionalidad al producto. Esto, en definitiva, consiste en varios ciclos de vida en cascada. Al final de cada iteración se entrega una versión mejorada. Las versiones que entregamos se corresponden con las cuatro grandes fases de la arquitectura que desarrollamos.</p>
<p>
<figure><img src="figures/iteraciones.png" /><figcaption>Esquema ciclo iterativo en cascada.</figcaption>
</figure>
</p></div><div id=EDT><h3>4.3 EDT</h3><p>Mostramos el desglose de las tareas más importantes para la correcta realización del proyecto. Para poder realizar un posterior seguimiento y control del proyecto asignamos a cada tarea un tiempo adecuado a la complejidad que estimamos para ésta. En caso de que posteriormente nos alejemos de lo que aquí planificamos, anotaremos dichas desviaciones en la sección de 'seguimiento y control'</p>
<table>
<thead>
<tr>
<th>Tarea</th>
<th>Descripción</th>
<th style="text-align: center;">Horas</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PLANIFICACIÓN</strong></td>
<td></td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td>INTRODUCCIÓN</td>
<td>Explicamos el contexto del problema planteado y cómo vamos a implementar la solución.</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>ALCANCE</td>
<td>Qué pretendemos conseguir con el proyecto acontando las tareas</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>RECURSOS HUMANOS</td>
<td>Aquellas personas que intervienen y la explicación de sus funciones</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>COMUNICACIONES</td>
<td>Elementos de comunicación interna y externa, incluimos interesados y clientes.</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>METODOLOGIA</td>
<td>Conjunto de procedimientos que usaremos para la planificación y gestión.</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>EDT Y TIEMPOS</td>
<td>Estructura en árbol con el desglose en tareas del trabajo junto con su estimación en tiempos</td>
<td style="text-align: center;">4</td>
</tr>
<tr>
<td>ENTREGABLES</td>
<td>Creación de los paquetes de trabajo del proyecto</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>GANTT</td>
<td>Tiempo determinado en el calendario para cada uno de los paquetes de trabajo.</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td>PLAN DE RIESGOS</td>
<td>Determinaremos los principales riesgos que pueden suceder durante el proyecto y los categorizaremos por nivel de impacto y de suceso.</td>
<td style="text-align: center;">2</td>
</tr>
<tr>
<td><strong>ANÁLISIS</strong></td>
<td></td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td>CONCEPTOS PREVIOS</td>
<td>Explicamos el contexto del problema planteado y cómo vamos a implementar la solución.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>PROYECTO AGRAI</td>
<td>Presentamos el estado actual de la aplicación AGRAI.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>AUTOMATIZACIÓN</td>
<td>Exponemos los distintos pasos a través de los cuales se transforman los datos.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>CATÁLOGO DE REQUISITOS</td>
<td>Obtendremos los requisitos funcionales y no funcionales del proyecto.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td><strong>INFRAESTRUCTURA</strong></td>
<td></td>
<td style="text-align: center;">25</td>
</tr>
<tr>
<td>ENTORNO</td>
<td>Decidimos los entornos de desarrollo necesarios así como las tecnologías necesarias en cada punto.</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td>INFRAESTRUCTURA CÓDIGO</td>
<td>Desarrollamos un script para dejar la máquina que contiene la aplicación en un estado estable con todas sus dependencias instaladas.</td>
<td style="text-align: center;">15</td>
</tr>
<tr>
<td><strong>DISEÑO</strong></td>
<td></td>
<td style="text-align: center;">100</td>
</tr>
<tr>
<td>ANÁLISIS MODELO PREVIO</td>
<td>Explicamos el contexto del modelo de datos previos y sus fallos.</td>
<td style="text-align: center;">30</td>
</tr>
<tr>
<td>REDISEÑO ENTIDADES</td>
<td>Explicamos qué entidades conformarán el modelo y por qué la base de datos quedará normalizada.</td>
<td style="text-align: center;">30</td>
</tr>
<tr>
<td>DISEÑO DE SERVICIOS</td>
<td>Encapsulamos las consultas más frecuentes en servicios fáciles de acceder.</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td>CARGA CON DATOS</td>
<td>Cargamos el modelo con datos para verificar su consistencia.</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td>DESPLIEGUE DE APLICACIÓN</td>
<td>Desplegamos la aplicación para comprobar su funcionamiento.</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td><strong>PIPELINE</strong></td>
<td></td>
<td style="text-align: center;">50</td>
</tr>
<tr>
<td>FUENTES DE DATOS</td>
<td>Explicamos las fuentes de datos con las que trabajamos.</td>
<td style="text-align: center;">15</td>
</tr>
<tr>
<td>DEFINICIÓN DE ETAPAS</td>
<td>Acotamos y definimos los pasos en los que se transforman los datos hasta llegar al modelo de forma consistente.</td>
<td style="text-align: center;">15</td>
</tr>
<tr>
<td>VISTA MINABLE</td>
<td>Seleccionamos del modelo relacional las 'features' para el modelo IA de producción.</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td><strong>MODELO IA</strong></td>
<td></td>
<td style="text-align: center;">50</td>
</tr>
<tr>
<td>DATOS</td>
<td>Exponemos los datos que vamos a utilizar, procedentes de la vista anterior.</td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td>MODELO DE PRODUCCIÓN</td>
<td>Usamos varias técnicas de Inteligencia Artificial para crear un modelo de producción de Kg para el cultivo.</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td>PREDICCIONES</td>
<td>Utilizamos el modelo anterior dentro del sistema para predecir los kg de cosecha a partir de una fecha dada.</td>
<td style="text-align: center;">20</td>
</tr>
<tr>
<td><strong>SEGUIMIENTO</strong></td>
<td></td>
<td style="text-align: center;">10</td>
</tr>
<tr>
<td>CONTROL</td>
<td>Realizamos pruebas de integración para asegurar la consistencia de los datos.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>GESTIÓN DE TIEMPOS</td>
<td>En una tabla registramos el tiempo estimado, el tiempo real invertido y la desviación del tiempo en cada una de las tareas del proyecto.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td><strong>MEMORIA</strong></td>
<td></td>
<td style="text-align: center;">25</td>
</tr>
<tr>
<td>ESTRUCTURA</td>
<td>Diseñamos la estructura basada en múltiples notas con la documentación y explicaciones del proyecto.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>REDACCIÓN</td>
<td>Redactamos la memoria a medida que avanza el proyecto.</td>
<td style="text-align: center;">15</td>
</tr>
<tr>
<td>EXPORTACIÓN</td>
<td>La memoria se escribe en notas de "markdown" debido a la simplicidad con la que se pueden integrar diagramas y código. Al terminarl, exportaremos la memoria como páginal "html".</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td>REVISIÓN</td>
<td>Al finalizar el proyecto, revisamos el escrito para asegurarnos de no cometer errores.</td>
<td style="text-align: center;">5</td>
</tr>
<tr>
<td><strong>TOTAL</strong></td>
<td></td>
<td style="text-align: center;">300</td>
</tr>
</tbody>
</table></div><div id=Entregables><h3>4.4 Entregables</h3><p>Para acotar el proceso de trabajo identificamos los siguientes entregables que generaremos a lo a medida que avance el proyecto. Estos entregables quedarán en la memoria en sus correspondientes apartados o como anexos si tienen una extensión más larga. La siguiente tabla contiene que lleva a cada uno de estos artefactos.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">IDENT</th>
<th style="text-align: left;">ENTREGABLE</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/tree/main/entregables/pipeline">E01</a></td>
<td style="text-align: left;">Módulo de Inicio</td>
<td style="text-align: center;">Análisis de viabilidad que permitirá determinar si es posible desarrollar el proyecto.</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://alesteba.github.io/tfg/#PLANIFICACI%C3%93N">E02</a></td>
<td style="text-align: left;">Planificación del proyecto</td>
<td style="text-align: center;">Determinaremos los requisitos del proyecto, crearemos un enunciado para el alcance, realizaremos una descripción detallada de tareas junto a una EDT, estimaremos el tiempo y coste de los paquetes de trabajo, desarrollaremos un cronograma, estableceremos los estándares, procesos y métricas de calidad, determinaremos un plan de identificación de riesgos y crearemos el plan de gestión de cambios.</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/tree/main/entregables/infraestructure">E03</a></td>
<td style="text-align: left;">Infraestructura como código</td>
<td style="text-align: center;">Desarrollo de un 'script' con las instrucciones bash para dejar la máquina que despliega la aplicación en un estado estable.</td>
</tr>
<tr>
<td style="text-align: left;"><a href="">E04</a></td>
<td style="text-align: left;">Documento de Diseño</td>
<td style="text-align: center;">Documento en el que se explican las decisiones tomadas para la creación de las entidades del modelo y sus relaciones.</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/tree/main/entregables/models.py">E05</a></td>
<td style="text-align: left;">Esquema modelo de Datos</td>
<td style="text-align: center;">Esquema UML que representa las entidades del modelo y sus relaciones. Modelo simplificado de datos exraido del ORM Django</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/tree/main/entregables/models.py">E06</a></td>
<td style="text-align: left;">Arquitectura Pipeline</td>
<td style="text-align: center;">Arquitectura y diagramas del proceso de transformación de datos, junto con sus scripts. Memoria + Código</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/blob/main/entregables/view.ipynb">E07</a></td>
<td style="text-align: left;">Vista Minable</td>
<td style="text-align: center;">Método algorítmico que genera la estructura tabular de datos necesaria para el modelo de producción</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/blob/main/entregables/view.ipynb">E08</a></td>
<td style="text-align: left;">Datos Vista</td>
<td style="text-align: center;">Estructura tabulada con las 'features' necesarias y los datos requeridos. (Estudio con 25 parcelas)</td>
</tr>
<tr>
<td style="text-align: left;"><a href="https://github.com/alesteba/tfg/blob/main/entregables/model_IA">E09</a></td>
<td style="text-align: left;">Modelo de producción</td>
<td style="text-align: center;">Cuaderno jupyter en el que buscamos el mejor modelo posible</td>
</tr>
</tbody>
</table></div><div id=Gantt><h3>4.5 Gantt</h3><p>El siguiente diagrama propone un desglose de tareas para la planificación del proyecto. Este diagrama es una estipulación de cómo se desarrolla el proyecto, en el eje horizontal, medimos el tiempo en días. Considerando 4 h de trabajo diarias, obtenemos una duración de 75 días para repartir las 300 h que dedicamos al trabajo. En la sección final de seguimiento y control analizamos las desviaciones encontradas y cómo han sido solucionados estos contratiempos.</p>
<p>'<img alt="" src="mermaid\output_0.png" />'</p>
<p>Destacamos que las tareas de escritura de la memoria y pruebas unitarias se realizan durante casi todo el proyecto. Las pruebas nos permiten asegurarnos de que el proyecto funciona adecuadamente: así no pasamos a una nueva tarea si no hemos dejado la aplicación estable al terminar la anterior.</p></div><div id=Comunicaciones><h3>4.6 Comunicaciones</h3><p>Para mantener informados tanto al tutor académico como a la tutora de la empresa, utilizaremos los siguientes canales:  </p>
<table>
<thead>
<tr>
<th style="text-align: left;">CANAL</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Reuniones</td>
<td style="text-align: center;">Presenciales, tanto con el tutor académico como con el tutor de la empresa.</td>
</tr>
<tr>
<td style="text-align: left;">Email</td>
<td style="text-align: center;">Forma de comunicación electrónica para concretar determinadas pautas o establecimiento de citas.</td>
</tr>
<tr>
<td style="text-align: left;">Discord</td>
<td style="text-align: center;">Aplicación de comunicación interna para mensajes directos con los miembros del equipo.</td>
</tr>
</tbody>
</table></div><div id=Riesgos><h3>4.7 Riesgos</h3><p>El objetivo de esta tabla es aumentar la probabilidad de eventos positivos y disminuir la de los negativos.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">FUENTE</th>
<th style="text-align: center;">RIESGO</th>
<th style="text-align: center;">SI SUCEDE</th>
<th style="text-align: center;">MINIMIZAR</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Ausencia de interesados</td>
<td style="text-align: center;">Médio</td>
<td style="text-align: center;">Utilizar menos reuniones y ser independiente</td>
<td style="text-align: center;">Planificar reuniones con antelación</td>
</tr>
<tr>
<td style="text-align: left;">Tecnología equivocada</td>
<td style="text-align: center;">Alto</td>
<td style="text-align: center;">Estudiar nuevas posiblidades</td>
<td style="text-align: center;">Uso de patrones abstractos elegantes que se puedan implementar en diferentes frameworks</td>
</tr>
<tr>
<td style="text-align: left;">Pérdida código fuente</td>
<td style="text-align: center;">Alto</td>
<td style="text-align: center;">Empezar casi de cero</td>
<td style="text-align: center;">Backups y control de versiones</td>
</tr>
<tr>
<td style="text-align: left;">Fallo de dependencias o librerías</td>
<td style="text-align: center;">Alto</td>
<td style="text-align: center;">Volver a crear los entornos</td>
<td style="text-align: center;">Utilizar técnias de infraestructura como código donde sea posible</td>
</tr>
<tr>
<td style="text-align: left;">Sobreajuste en los modelos</td>
<td style="text-align: center;">Medio</td>
<td style="text-align: center;">Probar otros algoritmos</td>
<td style="text-align: center;">Automatizar el proceso de búsqueda de los mejores algoritmos probando hiperparámetros.</td>
</tr>
<tr>
<td style="text-align: left;">Falta de horas para terminar el proyecto</td>
<td style="text-align: center;">Medio</td>
<td style="text-align: center;">Dedicarse primero a los requisitos más importantes.</td>
<td style="text-align: center;">Realizar una buena planificación y ajustar el alcance</td>
</tr>
</tbody>
</table>
<p>De la tabla anterior se prestará especial atención a los riesgos valorados como 'Alto', ya que por su incidencia en el proyecto requieren un seguimiento exhaustivo, para los cuales se desarrollarán sus correspondientes planes de contingencia. Los riesgos de valoración Media y Baja tendrán un control basado en un plan de mitigación simple de seguimientos del cronograma, con intervalos cortos de tiempo.</p></div><p style="page-break-after: always;">&nbsp;</p><div id=ANÁLISIS><h2>5 ANÁLISIS</h2><div id=Dominio_agronómico><h3>5.1 Dominio agronómico</h3><p>Una vez en contexto, procedemos a justificar las decisiones de diseño que la aplicación AGRAI necesita para llegar al rediseño que hemos identificado como clave.</p>
<p>AGRAI es una aplicación para la gestión de cultivo que permite al agricultor monitorizar el estado de sus parcelas. El estado actual de la aplicación se centra el despliegue de datos georreferenciados por medio de una interfaz web. Los resultados para el usuario de la aplicación son satisfactorios, permitiendo a éste consultar el estado de su parcelario junto con algunas predicciones en cualquier momento. </p>
<p>Tenemos que situarnos en el uso que se le está dando a la aplicación en relación con el diseño de ésta. La monitorización efectuada es válida para cualquier tipo de cultivo susceptible de ser fotografiado desde una imagen satelital y/o de dron. El modelo de datos que utiliza, aunque pobre al comienzo del trabajo, permite registrar tantos cultivos como un potencial cliente desee. Por otro lado, el caso real de uso de la aplicación proviene de bodegas o cooperativas vitivinícolas que quieren predecir la cantidad de kg de cosecha en una campaña determinada (2020-2021).</p>
<p>Como punto de partida buscaremos identificar las entidades del dominio necesarias para que nuestro nuevo modelo de datos represente y relacione toda la información con precisión.</p>
<p>En la interfaz web, el cliente observa un mapa con sus parcelas resaltadas en colores. Este color reflejado en los píxeles hace referencia a los índices vegetativos provenientes de las imágenes satelitales. Los clientes utilizan dicha interfaz para ver el estado de sus cultivos y observar la producción que predicen los modelos de Inteligencia Artificial generados.</p>
<p>
<figure><img src="figures/visor_GIS.png" /><figcaption>Captura del visor web en la que se aprecia cómo se monitorizan varias parcelas</figcaption>
</figure>
</p>
<p>A nivel interno, el equipo trabaja con datos provenientes de imágenes descargadas de satélites como SENTINEL, o de grabaciones realizadas por dron cuando se requiere una mayor calidad. Estos datos se mezclan con información proporcionada por estaciones meteorológicas como el SIAR y con la información que los clientes pueden proporcionar sobre campañas anteriores.</p>
<p>Por otro lado, el proceso actual de esta información es tedioso para el equipo. Los diferentes miembros trabajan con tecnologías distintas sobre datos, muchas veces duplicados, que provienen de fuentes comunes. Los requisitos que identificamos en el siguiente punto consideran la idea de optimización continua necesaria.</p></div><div id=Fuentes_de_datos><h3>5.2 Fuentes de datos</h3><p>Mencionábamos la búsqueda de optimización del proceso como una de las principales ideas para mejorar el flujo de datos que utiliza la aplicación. El rediseño que se quiere implantar y la arquitectura resultante tienen que cumplir con los principios de dicha metodología. Para que este trabajo resulte satisfactorio, el software tiene que poder utilizarse por el equipo con agilidad, consiguiendo que quede como una herramienta física que coordine bien todas las tareas de los participantes que la usan.</p>
<p>Para poder realizar este proyecto decidimos trabajar con un número pequeño representativo de datos de la aplicación, actualmente en producción. Un menor volumen de información permite realizar pruebas y da pie a fijarnos en las relaciones y los esquemas estructurales con más precisión.  </p>
<p>Como estamos buscando una optimización continua, a medida que voy haciendo pruebas con mi entorno local, un compañero se encarga de utilizar el mismo proyecto con volúmenes mayores de datos, que la aplicación utiliza en producción. La reestructuración del modelo de BD que realizamos contempla un posterior escalado de la aplicación que permitirá la integración continua con más datos y nuevas tecnologías.</p>
<p>La siguiente tabla muestra las principales fuentes de datos de las que se obtienen y enlaza la información. El volumen de datos que se puede llegar a manejar es grande ya que por cada parcela se almacenan varios índices vegetativos en cada uno de sus píxeles. </p>
<table>
<thead>
<tr>
<th style="text-align: left;">FUENTE DATOS</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">QGIS</td>
<td style="text-align: center;">Información geomométrica de parcelas y sus pixéles</td>
</tr>
<tr>
<td style="text-align: left;">Índices Vegetativos</td>
<td style="text-align: center;">Información provenientes de imágenes satelitales descargadas en diferentes fechas</td>
</tr>
<tr>
<td style="text-align: left;">Cultivos / Variedad</td>
<td style="text-align: center;">Información tabulada en excels sobre tipo de cultivos y sus variedades</td>
</tr>
</tbody>
</table>
<p>Para poder realizar el trabajo utilizaremos, por tanto, una muestra representativa de los datos debido a que el proceso de descarga de índices y persistencia de datos es largo para realizar las pruebas. El sistema está pensado para trabajar con muchas parcelas; en las pruebas que yo voy a realizar escogemos una muestra de 25 parcelas y pensaremos una descarga de índices para no más de 4 fechas diferentes.</p>
<p>Para hacernos una idea, contemplando solo 25 parcelas, podemos almacenar 3000 píxeles. Por cada pixel vamos a registrar varios índices vegetativos (ndvi, ndre) y para generar el histórico de datos esta información se multiplica por el número de fechas contempladas. Es decir, que aunque trabajamos sobre un volumen reducido para probar la automatización, sigue siendo mucha la información que tiene que almacenarse en la base de datos.</p>
<p>Es el histórico de índices en diferentes fechas lo que permite al sistema realizar modelos predictivos. A mayor volumen de datos, más precisión podremos obtener en los modelos posteriormente. El punto importante de este trabajo es la mejora del proceso y la automatización del flujo de datos; ello nos llevará a que finalmente podamos obtener un modelo de regresión para predecir los kg de cultivo, tal y como el agricultor necesita. La muestra que utilizamos, al ser representativa con 25 parcelas, predecirá con un cierto sobreajuste a los datos. Por tanto nuestro esfuerzo se centra en que el proceso que implantamos sea reproducible para cualquier volumen de datos, y en que sin desarrollo adicional podamos utilizar el mismo proceso para predecir en el volumen que queramos.</p></div><div id=Automatizacion><h3>5.3 Automatizacion</h3><p>El proceso que vamos a implantar requiere de un diseño que posibilite estructurar y manejar grandes volúmenes de datos. Actualmente, existen varias tecnologías que abordan el concepto de <em>Pipeline</em> desde un punto de vista global. No vamos a utilizar ninguna de estas tecnologías; nuestro proceso se va a desarrollar a medida, modelando un Pipeline como patrón de diseño, encargado de la transformación de los datos en bloques reutilizables para su persistencia en el modelo.</p>
<p>El primer paso para realizar una carga de datos, es el diseño de un modelo relacional que soporte esta información de la forma más estructurada y organizada posible. Hará falta la comprensión de conceptos del dominio agronómico para dar sentido a esta información y obtener así un esquema sólido sobre el que poder preguntar sin limitaciones.</p>
<p>'<img alt="" src="mermaid\output_1.png" />'</p>
<p>Con un modelo relacional para los datos, los bloques atómicos de carga se podrán ejecutar periódicamente utilizando las fuentes de datos necesarias. El proceso de automatización termina, una vez que están almacenados los datos, con la extracción de una vista minable que permite obtener el mejor modelo de regresión para los kg de cultivo que se van a cosechar en una fecha determinada.</p></div><div id=Tecnologías><h3>5.4 Tecnologías</h3><p>El código de la aplicación que heredamos está escrito en Python. El lenguaje es una decisión adecuada debido a la necesidad de integrar técnicas de procesamiento de datos e inteligencia artificial. El framework de Django para Python permite construir un proyecto robusto y desplegarlo en un servidor con una interfaz web.</p>
<p><em>Django</em> nos ofrece las herramientas necesarias para trabajar desde un alto nivel de abstracción y poder diseñar una aplicación sólida y estable. Algunas de estas herramientas son:</p>
<ul>
<li>ORM, Object-Relational-Mapping: permite crear un modelo de datos y gestiona automáticamente la BD (base de datos) subyacente. Abstrae las consultas SQL y evita tener que realizar migraciones manuales de los esquemas.</li>
<li>Static File Generator: podemos diseñar la interfaz de la aplicación en formato web y desplegar en un servidor.</li>
<li>Commands-System: gestión de comandos internos mediante los que se puede automatizar tareas; utilizaremos esta arquitectura para diseñar el pipeline de datos y almacenar la información proveniente de diferentes fuentes.</li>
</ul>
<p>
<figure><img src="figures/django-commands.png" /><figcaption>Ejemplo de uso de un comando en Django para ejecutar la descarga de los índices (salida del comando mostrada en Jenkins).</figcaption>
</figure>
</p>
<p>Aunque el framework es muy potente, harán falta otras herramientas y entornos para completar con éxito la automatización que buscamos para así conseguir un proceso de optimización continua. En el siguiente punto hablaremos de la infraestructura que la aplicación requiere y de cómo podemos solventar algunos de los problemas de integración más importantes. Mencionamos algunas de estas tecnologías:</p>
<ul>
<li>Vagrant: virtualización de una máquina Unix en la que podamos provisionar el proyecto y reproducir los pasos necesarios de nuestro pipeline.</li>
<li>Jenkins: herramienta de integración continua que permite declarar un pipeline a modo de infraestructura como código. </li>
</ul>
<p>La utilización de <em>Python</em>, aparte de incluir el framework de Django, nos da la posibilidad de utilizar las librerías de inteligencia artificial y ciencia de datos que son necesarias para la creación del modelo de producción de cultivo. Algunas de librerías principales que vamos a utilizar son las siguientes:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">LIBRERÍA</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">scikit-learn</td>
<td style="text-align: center;">Creación de modelos de inteligencia artificial</td>
</tr>
<tr>
<td style="text-align: left;">numpy</td>
<td style="text-align: center;">Tratamiento de datos multidimensionales</td>
</tr>
<tr>
<td style="text-align: left;">pandas</td>
<td style="text-align: center;">Uso de datos tabulados con herramientas para su procesamiento</td>
</tr>
<tr>
<td style="text-align: left;">jupyter</td>
<td style="text-align: center;">Integración de cuadernos procesables con el resto del proyecto</td>
</tr>
</tbody>
</table></div><div id=Requisitos><h3>5.5 Requisitos</h3><p>La siguiente tabla muestra los requisitos funcionales críticos para completar con éxito el proyecto, terminando el trabajo con un producto estable que el equipo pueda utilizar.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">REQUISITO</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">RF1</td>
<td style="text-align: center;">Automatizar el despliegue de la aplicación identificando las librerías y dependencias necesarias.</td>
</tr>
<tr>
<td style="text-align: left;">RF2</td>
<td style="text-align: center;">Rediseñar el modelo de datos para poder escalar la aplicación y su gestión de datos.</td>
</tr>
<tr>
<td style="text-align: left;">RF3</td>
<td style="text-align: center;">Documentar el proceso de desarrollo generando los documentos de diseño pertinentes.</td>
</tr>
<tr>
<td style="text-align: left;">RF4</td>
<td style="text-align: center;">Crear un entorno común que permita trabajar al equipo sobre las mismas fuentes de datos.</td>
</tr>
<tr>
<td style="text-align: left;">RF5</td>
<td style="text-align: center;">Obtener una vista minable con la selección de <em>features</em> provenientes del modelo.</td>
</tr>
<tr>
<td style="text-align: left;">RF6</td>
<td style="text-align: center;">Creación de un modelo de producción probando varios algoritmos de inteligencia artificial.</td>
</tr>
<tr>
<td style="text-align: left;">RF7</td>
<td style="text-align: center;">Despliegue de los datos del modelo en la interfaz de la aplicación.</td>
</tr>
</tbody>
</table>
<p>Como requisitos no funcionales para la aplicación identificamos los siguientes, entendiendo que se completarán a lo largo de todo el proyecto. </p>
<table>
<thead>
<tr>
<th style="text-align: left;">REQUISITO</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">RNF1</td>
<td style="text-align: center;">Crear un entorno Linux local con la misma configuración necesaria en producción.</td>
</tr>
<tr>
<td style="text-align: left;">RNF2</td>
<td style="text-align: center;">Preparar las fuentes de datos con una muestra pequeña representativa de la aplicación en producción.</td>
</tr>
<tr>
<td style="text-align: left;">RNF3</td>
<td style="text-align: center;">Estudiar las posibles features para la vista minable que utilizará el modelo de producción de cultivo</td>
</tr>
<tr>
<td style="text-align: left;">RNF4</td>
<td style="text-align: center;">Implantar un flujo de trabajo en el equipo para utilizar las mismas fuentes de datos</td>
</tr>
<tr>
<td style="text-align: left;">RNF5</td>
<td style="text-align: center;">Utilizar software libre</td>
</tr>
</tbody>
</table></div><p style="page-break-after: always;">&nbsp;</p><div id=INFRAESTRUCTURA><h2>6 INFRAESTRUCTURA</h2><div id=Arquitectura_física><h3>6.1 Arquitectura física</h3><p>El entorno local, sobre el cual desarrollamos, y el de producción, donde se despliega la aplicación, son actualmente diferentes. Todos los miembros del equipo utilizamos máquinas Windows, mientras que en el servidor de producción encontramos una máquina Ubuntu. Esto crea un problema importante en el proceso de instalación de las librerías necesarias para trabajar con los datos; se pierde gran cantidad de tiempo en preparar el entorno de cada persona que va a trabajar con el repositorio de la aplicación; además, las librerías necesarias necesitan de una gran cantidad de dependencias que varían en cuanto a las versiones. Como solución propondremos una nueva forma de trabajo que nos asegure un entorno común con las mismas librerías y paquetes.</p>
<p>Parte del trabajo consiste en la automatización del despliegue de la aplicación. En este punto veremos cómo la infraestructura como código permite aislar las librerías necesarias creando un script que deja una máquina en estado estable para ejecutar la aplicación. Para poder utilizar tecnologías que posibiliten la integración continua, transformamos el entorno de desarrollo desplegando la aplicación en UNIX mediante una máquina virtual Vagrant en la que podamos reproducir varias veces el proceso. Identificamos las siguientes dependencias que necesitan ser instaladas:</p>
<ul>
<li>Postgres 14 + Postgis</li>
<li>Python3.10</li>
<li>GDAL 3.3.2</li>
<li>Django</li>
<li>Jenkins</li>
</ul>
<p>Suele ser complicado encontrar todas las dependencias con sus versiones correctas; en este caso el punto más complicado ha sido la instalación de Python con su versión correspondiente de GDAL, librería que permite tratar con los datos geoespaciales. Además, el sistema gestor de BD, 'postgres', necesita una extensión especial, 'postgis', para poder guardar los datos georreferenciados. Como este tipo de trabajo es casi de prueba y error, la utilidad del script que obtenemos es de gran valor.</p>
<p>Jenkins es una herramienta de integración continua muy relevante para el proceso de automatización y mejora continua que queremos implantar. Aquí mencionamos cómo se incluye en la máquina Vagrant que contiene el proyecto. En los siguientes puntos veremos cómo permite integrar los distintos scripts de carga de datos junto con la generación de la vista minable y posterior modelo que conformar el pipeline que queremos conseguir.</p></div><div id=Vagrant><h3>6.2 Vagrant</h3><p>Hacemos uso de Vagrant para crear, en una máquina virtual Unix (Ubuntu), el entorno de desarrollo necesario para el proyecto. De esta forma conseguimos que los entornos de pruebas y producción sean muy similares, permitiendo automatizar el despliegue de la aplicación mediante técnicas de infraestructura como código. Una de las ventajas de tener una máquina Ubuntu, es que, mediante scripts .sh, instalamos todas las dependencias necesarias para dejar dicha máquina lista para el despliegue de la aplicación.</p>
<p>Para el entorno de desarrollo virtualizamos con Vagrant una máquina Ubuntu 20.04. El archivo <em>Vagrantfile</em> nos permite provisionarla con el código del proyecto y el script que deja a dicha máquina con las librerías necesarias para el correcto funcionamiento de este.</p>
<div class="codehilite"><pre><span></span><code>Vagrant.configure<span class="o">(</span><span class="s2">&quot;2&quot;</span><span class="o">)</span> <span class="k">do</span> <span class="p">|</span>config<span class="p">|</span>

  config.vm.box <span class="o">=</span> <span class="s2">&quot;bento/ubuntu-20.04&quot;</span>

  config.vm.provision <span class="s2">&quot;file&quot;</span>, source: <span class="s2">&quot;~/Desktop/agrai&quot;</span>, destination: <span class="s2">&quot;</span><span class="nv">$HOME</span><span class="s2">/&quot;</span>
  config.vm.provision :shell, :path <span class="o">=</span>&gt; <span class="s2">&quot;start.sh&quot;</span>
  config.vm.provision :shell, :path <span class="o">=</span>&gt; <span class="s2">&quot;jenkins.sh&quot;</span>

  config.vm.define <span class="s2">&quot;server&quot;</span> <span class="k">do</span> <span class="p">|</span>server<span class="p">|</span>
      server.vm.network <span class="s2">&quot;private_network&quot;</span>, ip: <span class="s2">&quot;192.168.56.19&quot;</span>
       server.vm.provider <span class="s2">&quot;virtualbox&quot;</span> <span class="k">do</span> <span class="p">|</span>vb<span class="p">|</span>
          vb.memory <span class="o">=</span> <span class="s2">&quot;4096&quot;</span>
          vb.cpus   <span class="o">=</span> <span class="s2">&quot;2&quot;</span>
      end
  end
</code></pre></div>

<p>Se enlazan como entregables los dos scripts con los que provisionamos dicha máquina. El primero, 'start.sh', hace referencia a la instalación de las librerías necesarias, el segundo, instala la herramienta Jenkins para la posterior ejecución de tareas dentro de un pipeline. A continuación mostramos algunas de las dependencias que más ha costado que funcionen conjuntamente.</p>
<div class="codehilite"><pre><span></span><code><span class="ch">#!/bin/bash</span>
sudo apt install -y postgresql-14 
sudo apt install -y postgresql-14-postgis-scripts

<span class="c1"># gdal native:</span>
sudo add-apt-repository ppa:ubuntugis/ppa <span class="o">&amp;&amp;</span> sudo apt-get update

<span class="c1"># python concrete installation</span>
sudo apt install -y python3.10 <span class="c1"># version concreta </span>
sudo apt install -y python3.10-dev python3.10-venv
sudo apt install -y virtualenv
sudo apt install -y build-essential
sudo apt install -y python3.10-tk

<span class="c1">#Tkinter</span>
sudo apt install -y python3-tk

<span class="c1"># GDAL</span>
sudo apt install -y libgdal-dev
sudo apt install -y gdal-bin

<span class="c1"># env gdal lib variables</span>
<span class="nb">export</span> <span class="nv">CPLUS_INCLUDE_PATH</span><span class="o">=</span>/usr/include/gdal
<span class="nb">export</span> <span class="nv">C_INCLUDE_PATH</span><span class="o">=</span>/usr/include/gdal
</code></pre></div></div><div id=Entorno><h3>6.3 Entorno</h3><p>Por último, es importante preparar un entorno común para el equipo. Django es un framework muy útil por la integración de las herramientas que hemos visto (ORM, integración continua, etc.), pero para conseguir un <em>workflow</em> adecuado necesitamos incluir otras herramientas propias de ciencia de datos como pueden ser cuadernos de Jupyter y sus entornos, con las librerías necesarias para ejecutar modelos predictivos.</p>
<p>Dedicamos varios días a preparar la integración de Django con cuadernos Jupyter y a ejecutar diferentes entornos virtuales con las librerías adecuadas en cada momento. Los siguientes ejemplos muestran cómo se ha conseguido integrar las librerías necesarias para el despliegue de los cuadernos y su integración con los datos y los modelos de Django. El siguiente snippet es relevante debido a que se necesita ejecutar en la primera celda del cuaderno para tener acceso a los modelos y servicios definidos en la arquitectura de Django.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># base code for jupyter integration</span>

<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">django</span>

<span class="n">BASE_DIR</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="s1">&#39;../../agrai/&#39;</span><span class="p">))</span>

<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">BASE_DIR</span><span class="p">)</span>

<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;DJANGO_SETTINGS_MODULE&quot;</span><span class="p">,</span> <span class="s2">&quot;agrai.settings&quot;</span><span class="p">)</span>

<span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;DJANGO_ALLOW_ASYNC_UNSAFE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;true&quot;</span>

<span class="n">django</span><span class="o">.</span><span class="n">setup</span><span class="p">()</span>
</code></pre></div>

<p>Los cuadernos Jupyter que se encuentran en esta memoria se han exportado desde la propia aplicación. Vemos la facilidad con la que el equipo puede redactar informes para clientes concretos, utilizando los datos de la aplicación directamente.  El código anterior es el 'snippet' necesario para poder integrar los cuadernos con las llamadas concretas a los modelos de Django. Estos cuadernos son un punto tan importante de la arquitectura como puede ser el módulo de servicios.</p></div><p style="page-break-after: always;">&nbsp;</p><div id=DISEÑO><h2>7 DISEÑO</h2><div id=Carga_de_datos><h3>7.1 Carga de datos</h3><p>Un modelo claro y robusto va a permitir cargar datos en la aplicación de forma ordenada con posibilidad de ser escalados en el futuro. En la implementación del pipeline que veremos en siguientes apartados haremos hincapié en los estados de carga por los que pasan los datos; de momento solo importa destacar que el modelo actual permite mantener un histórico de datos mucho más sólido que el que estaba implantado cuando comenzamos el desarrollo. </p>
<p>Es importante explicar por qué vamos a poner tanto énfasis en que estos datos se gestionen de manera fluida y eficaz. La interfaz web de la aplicación muestra la punta de un iceberg en la que el usuario observa las parcelas coloreadas basándose en los índices vegetativos, también se muestra la producción estimada.</p>
<p>
<figure><img src="figures/load.png" /><figcaption>Ejecución del pipeline mientras realiza la descarga de datos del satélite Copernicus.</figcaption>
</figure>
</p>
<p>El proceso de carga de datos hace uso de un módulo de descarga de imágenes satelitales que obtiene el valor de estos índices vegetativos. Este script de descarga ha sido desarrollado por el equipo y ha sido colocado dentro del módulo de automatización junto con otras tareas similares. Utilizaremos el módulo como una caja negra y aseguraremos el correcto uso de este para que los índices vegetativos terminen en sus tablas correspondientes dentro de la BD.</p>
<p>Los índices que renderiza el visor de la aplicación son el resultado de todo el proceso que estamos exponiendo. Es el punto más delicado que requiere del diseño de varias entidades para guardar un histórico de datos. En la visualización del histórico de índices vegetativos es el mayor valor que obtiene el cliente cuando accede a la aplicación.</p></div><div id=Modelo_relacional><h3>7.2 Modelo relacional</h3><p>Como inicio de la posterior automatización, se reestructura la arquitectura de la aplicación junto con su BD para soportar el almacenamiento de nuevos datos. El siguiente esquema de BD es el resultado de la implementación del análisis descrita en el planteamiento.</p>
<p>
<figure><img src="figures/modelo-end.png" /><figcaption>Esquema relacional en uso del componente principal de la aplicación</figcaption>
</figure>
</p>
<p>Para la creación de este modelo he trabajado con el equipo en la identificación de los conceptos que necesitaban ser representados. El diseño en papel da la posibilidad de pensar abiertamente sobre las relaciones entre entidades, además de permitir la transmisión de ideas de forma sencilla durante las reuniones.</p>
<p>Dentro del entorno de trabajo de <em>Django,</em> el ORM proporcionado aísla la base de datos y nos permite diseñar directamente en <em>Python</em> dicho modelo. Las entidades se diseñan como clases y las relaciones entre ellas se especifican mediante el lenguaje de mapeo proporcionado. De dicha forma creamos las claves foráneas que físicamente contiene la base de datos.</p>
<p>La utilización de este ORM es una ventaja que nos evita usar SQL directamente y permite poblar la base de datos mediante comandos <em>Python</em> desde la terminal. De todas formas, la localización física de la BD necesita ser enlazada correctamente. Este aislamiento posibilita utilizar diferentes bases de datos en los entornos locales y de producción.</p>
<p>Varias etapas han sido necesarias hasta llegar a un punto más o menos estable. La herramienta <em>Graphviz</em> ha permitido obtener diagramas UML que visualizan la estructura de clases del modelo a partir del código. Esta representación gráfica ha sido realmente útil para poder pensar sobre el diseño a medida que avanzaba.</p>
<B>Entidades Principales</B>
<p>De la situación inicial, nos quedamos solo con las entidades principales. Esta selección de entidades se realiza cuidadosamente para que la aplicación pueda contemplar la mayor información posible haciendo uso de un esquema sencillo pero robusto. Analizamos el diseño detalladamente en los siguientes puntos.</p>
<p>
<figure><img src="figures/spectralgeo_db.png" title="original" /><figcaption>Esquema relacional inicial de partida, con entidades definidas, pero sin implementar, se toma como idea para el comienzo del diseño.</figcaption>
</figure>
</p>
<p>Este rediseño contempla la mayoría de casos posibles para el posterior tratamiento y procesamiento de datos, con posibilidad de crear buenos modelos predictivos. A continuación se describen las entidades principales contempladas en la base de datos.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">ENTIDAD</th>
<th style="text-align: left;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Parcela</td>
<td style="text-align: left;">Como toda la información que se va a almacenar es referente a las parcelas y sus datos, toda la BD gira en torno a la tabla “Parcela”.</td>
</tr>
<tr>
<td style="text-align: left;">Cultivo</td>
<td style="text-align: left;">Esta tabla está directamente unida a la anterior, ya que un cultivo puede tener muchas variedades diferentes se modela de forma recursiva con una clave foránea a sí mismo (leer el siguiente punto, Ej: Guisante es un tipo de cultivo, pero tiene varias variedades: tirabeque, snap peas…).</td>
</tr>
<tr>
<td style="text-align: left;">Indice</td>
<td style="text-align: left;">Esta taba es de vital importancia para el funcionamiento de la aplicación, toda nuestra información lleva a estos datos vegetativos. Serán datos calculados en un dominio, esto se hace así ya que existen cientos de formas de denominar un mismo índice de vegetación y podría ser confuso a la hora de realizar las consultas. Para ello se establecerán algunos campos determinados en el campo “tipo_indice” y se les dará un valor en “valor_indice”.</td>
</tr>
<tr>
<td style="text-align: left;">Mirar_Indice</td>
<td style="text-align: left;">Contempla un histórico de datos y permite dar valor concreto a un índice vegetativo en una fecha única.</td>
</tr>
<tr>
<td style="text-align: left;">Fenologico</td>
<td style="text-align: left;">Permite registrar diferentes estados fenológicos por los que puede pasar un cultivo. La relación entre el estado fenológico y el cultivo se realiza a través de la tabla Mirar_Fenologico.</td>
</tr>
<tr>
<td style="text-align: left;">Mirar_Fenologico</td>
<td style="text-align: left;">Permite dar carácter temporal al estado fenológico de un cultivo. Registramos un estado para un cultivo en una fecha concreta.</td>
</tr>
<tr>
<td style="text-align: left;">Campaña</td>
<td style="text-align: left;">Es una tabla muy importante, sirve para unir distintos tipos de registros (desde variedades hasta labores de campo pasando por unir los datos de parcelas y subparcelas).</td>
</tr>
<tr>
<td style="text-align: left;">Interesado</td>
<td style="text-align: left;">Permite realizar el diseño de roles mediante su clave foránea a una parcela. Un intereseado (stakeholder) es una persona que tiene relación con una o varias parcelas (Ej, cultivador, propietario, etc).</td>
</tr>
</tbody>
</table>
<B>Diseño del Cultivo y Fenología</B>
<p>Una decisión complicada sobre el posible histórico de datos es el registro de la evolución de un cultivo en una parcela concreta. Mediante la tabla MIRAR_FENOLÓGICO damos carácter temporal al cultivo concreto de una parcela. De esta forma podemos registrar cuáles son los estados por los que ha pasado un cultivo, desde su "siembra" hasta su "recolección".</p>
<p>El modelado de la entidad FENOLÓGICO ha sido una decisión complicada debido a que no se enlaza directamente con un cultivo. Entendemos que un estado como puede ser el de "siembra" tiene un carácter general y tiene sentido como entidad en sí misma (todos los cultivos pasan por siembra). Es su relación con CULTIVO mediante MIRAR_FENOLÓGICO lo que dice que dicho cultivo está en un estado fenológico concreto en un momento determinado. Por ejemplo, podemos decir que el cultivo "vid" estaba en estado de "siembra" el día "2022-01-23". </p>
<p>También es importante destacar que CULTIVO es simplemente el tipo que se ha registrado, por lo tanto, para que la información sea completa, un avistamiento fenológico sucede sobre un tipo de cultivo físicamente sembrado en una PARCELA.  En la próxima figura podemos ver cómo estas tres entidades se relacionan para dar carácter temporal y espacial a un tipo de cultivo.</p>
<p>Otro punto importante de la aplicación es la contemplación de variedades. Para poder mantener una jerarquía con las posibles entidades registradas en el sistema, enlazamos de forma recursiva el cultivo con una clave foránea a su misma tabla. Esta estructura permite el desglose de una jerarquía de cultivos en la que sabemos qué entidad es una subvariedad de un cultivo, dando la posibilidad de almacenar múltiples niveles.</p>
<p>
<figure><img src="figures/mirar_feno.png" /><figcaption>Ejemplo de una consulta SQL sobre la tabla MIRAR_FENOLÓGICO</figcaption>
</figure>
</p>
<B>Diseño de Índices Vegetativos</B>
<p>Para nuestro sistema de información una parcela es una agrupación de varios píxeles. Entendemos como PIXEL a la imagen satelital más pequeña que se puede obtener sobre el terreno, a partir de la cual obtendremos los índices vegetativos. <em>(El valor del índice es una caja negra para este trabajo, proviene de scripts desarrollados por el resto del equipo)</em></p>
<p>El trabajo con índices vegetativos por parte del equipo es uno de los puntos más importantes para que el rediseño sea satisfactorio. La entidad MIRAR_ÍNDICE es de vital importancia en el modelo, permite gestionar el histórico de valores de los índices para todos los píxeles. Esta tabla es una de las candidatas para realizar optimización en las consultas, algo que desde el ORM que utilizamos todavía queda un poco lejos. </p>
<p>El volumen de datos que la tabla MIRAR_INDICE puede contener es grande. Solo con la muestra representativa de las 25 parcelas con las que estamos trabajando (3000 píxeles), dos índices registrados, y contemplando sus valores en 6 fechas distintas, obtenemos un conjunto de 36.000 valores. Cuando la aplicación escale a un mayor número de parcelas, esta tabla será susceptible de utilizar índices (BD).</p>
<p>Este diseño de índices permite mantener un histórico de datos preciso. Gestiona la evolución de los cultivos a través de las diferentes fechas en las que se persisten los valores de los índices. Destacamos que cada índice se corresponde con una capa de visualización sobre el visor GIS que contiene la presentación de la aplicación, requisito que hace que tenga mucha importancia el poder añadir índices a los datos a media que se vayan contemplando.</p>
<B>Diseño de Roles</B>
<p>Aunque es un punto secundario, la aplicación contempla que diferentes usuarios puedan realizar diferentes acciones. Recordamos que habíamos separado en componentes la aplicación, y los roles se encuentran en un módulo secundario independiente de las entidades anteriores, que representaban los principales conceptos agronómicos y vegetativos. El diseño modular del modelo de datos permite al equipo añadir diferentes roles sin que estos estén <em>hardcoded</em> en el código de la aplicación. La siguiente tabla describe los roles hasta ahora contemplados por el equipo y su relación con el parcelario.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">ROL</th>
<th style="text-align: center;">DESCRIPCIÓN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">Cultivador</td>
<td style="text-align: center;">persona encargada de realizar los mantenimientos en campo</td>
</tr>
<tr>
<td style="text-align: left;">Propietario</td>
<td style="text-align: center;">propietario catastral de las parcelas</td>
</tr>
<tr>
<td style="text-align: left;">Cooperativa</td>
<td style="text-align: center;">entidad que agrupa a técnos con diferentes cargos sobre un parcelario</td>
</tr>
<tr>
<td style="text-align: left;">Técnico</td>
<td style="text-align: center;">personal asignado a un número de parcelas.</td>
</tr>
</tbody>
</table>
<p>Aunque la aplicación hace uso de estas entidades, no serán tan importantes para el desarrollo posterior del trabajo, debido a que la parte que necesita automatizarse es aquella relacionada con los índices vegetativos y la geometría de las parcelas anteriores. Como decíamos, estas entidades quedan separadas en un módulo de la aplicación con la única funcionalidad de controlar el acceso a la aplicación y dar permiso a las funcionalidades que cada cliente puede realizar dependiendo del rol que tenga asignado.</p>
<B>Modelo Final</B>
<p>El siguiente diagrama recoge todas las relaciones descritas anteriormente y muestra el esquema completo que usa la aplicación. En los siguientes puntos hablaremos sobre los métodos definidos sobre este esquema de datos, dónde se localizan y cómo han de ser utilizados.</p>
<p>'<img alt="" src="mermaid\output_2.png" />'</p></div><div id=Servicios><h3>7.3 Servicios</h3><p>Ahora tenemos un modelo relacional que soporta la gestión de grandes volúmenes de datos. En este punto tenemos que diseñar las diferentes operaciones que necesitamos hacer sobre los datos almacenados. Discutimos cómo tiene que ser la implementación de las operaciones más frecuentes y por qué en un modelo de datos sin estado, con información histórica, es más importante diseñar estas operaciones sobre el modelo relacional como servicios.</p>
<p>El término servicio está sobrecargado y su significado adquiere diferentes matices según el contexto en que estemos. Como resultado, existe una nube de confusión en torno a la noción de servicios cuando se trata de distinguir entre servicios de aplicación, servicios de dominio, servicios de infraestructura, servicios SOA, etc. Las funciones de estos son diferentes y pueden abarcar todas las capas de una aplicación.</p>
<p>De hecho, un servicio es un título un tanto genérico para un bloque de creación de una aplicación porque implica muy poco. En primer lugar, un servicio implica un cliente para cuyas solicitudes está diseñado. Otra característica de una operación de servicio es la de entrada y salida: se proporcionan argumentos  como entrada a una operación y se devuelve un resultado. Ms allá de esta implicación suelen estar los supuestos de "statelessness" y la idea de "pure fabrication", según GRASP:</p>
<p><strong>When a significant process or transformation in the domain is not a natural responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as standalone interface declared as a SERVICE. Define the interface in terms of the language of the model and make sure the operation name is part of the UBIQUITOUS LANGUAGE. Make the SERVICE stateless.</strong></p>
<p><strong>Eric Evans</strong> Domain-Driven Design</p>
<p>El tipo de servicios que estamos diseñando e implementando para nuestra aplicación forman parte de la capa de dominio. Estos servicios de dominio a menudo se pasan por alto como bloques de construcción clave, confundidos por el enfoque de las entidades del modelo (o value objects).</p>
<p>Cumpliendo con los principios mencionados, los servicios conforman la siguiente capa de abstracción del modelo de datos implementado. Colocaremos aquellas operaciones que dependan o relacionen más de una entidad en su módulo correspondiente de servicios y no como un método de la clase del modelo. Este tipo de diseño en el que dejamos el modelo casi sin métodos propios puede llegar a entenderse como un anti-patrón, <a href="http://martinfowler.com/bliki/AnemicDomainModel.html">anemic domain model</a>, pero que en nuestro caso, tras buscar la forma más sencilla de acceder a la información, será de gran utilidad.</p>
<p>Justificamos la implementación de gran parte de los métodos sobre la capa de servicios por el tipo de información histórica sobre la que necesitamos hacer las consultas. La mayoría de entidades necesitan de una relación con otra segunda o tercera entidad para devolver la información pertinente. <strong>Como el modelo está orientado a manejar información histórica y sin estado</strong>, optamos por colocar casi todos los métodos de acceso a los datos en un módulo de servicios aparte. Miremos el siguiente ejemplo sobre los históricos fenológicos en el parcelario registrado.</p>
<div class="codehilite"><pre><span></span><code><span class="k">class</span> <span class="nc">ParcelaCultivos_Service</span><span class="p">():</span>

    <span class="k">def</span> <span class="nf">get_cultivo</span><span class="p">(</span><span class="n">parcela_p</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; último cultivo que se está cultivando en una parcela &quot;&quot;&quot;</span>

        <span class="n">mirar_feno</span> <span class="o">=</span> <span class="n">Mirar_Fenologico</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parcela</span> <span class="o">=</span> <span class="n">parcela_p</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">mirar_feno</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>

            <span class="k">return</span> <span class="n">mirar_feno</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="s1">&#39;fecha&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cultivo</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_historico_fenologicos</span><span class="p">(</span><span class="n">parcela_p</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; todos los estados fenológicos por los que ha pasado una parcela &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Mirar_Fenologico</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parcela</span> <span class="o">=</span> <span class="n">parcela_p</span><span class="o">.</span><span class="n">referencia</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_historico_range</span><span class="p">(</span><span class="n">fecha_inicio</span><span class="p">,</span> <span class="n">fecha_end</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; histórico de todas las parcelas en un rango de fechas &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Mirar_Fenologico</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">fecha__range</span><span class="o">=</span><span class="p">[</span><span class="n">fecha_inicio</span><span class="p">,</span> <span class="n">fecha_end</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">get_historico_parcela</span><span class="p">(</span><span class="n">parcela1</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; todo el histórico de una parcela &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Mirar_Fenologico</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parcela</span> <span class="o">=</span> <span class="n">parcela1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_historico_parcela_range</span><span class="p">(</span><span class="n">parcela1</span><span class="p">,</span> <span class="n">fecha_inicio</span><span class="p">,</span> <span class="n">fecha_end</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; hostórico de una parcela en un rango de fechas &quot;&quot;&quot;</span>

        <span class="n">historico</span> <span class="o">=</span> <span class="n">ParcelaCultivos_Service</span><span class="o">.</span><span class="n">get_historico_range</span><span class="p">(</span><span class="n">fecha_inicio</span><span class="p">,</span> <span class="n">fecha_end</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">historico</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parcela</span> <span class="o">=</span> <span class="n">parcela1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_historico_mismo_fenologico</span><span class="p">(</span><span class="n">valor_fenologico</span><span class="p">):</span>

        <span class="sd">&quot;&quot;&quot; todo los cultivos que están en un mismo estado fenológico &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">Mirar_Fenologico</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">estado</span> <span class="o">=</span> <span class="n">valor_fenologico</span><span class="p">)</span>
</code></pre></div>

<p><a href="https://github.com/alesteba/tfg/tree/main/entregables/services">Adjuntamos</a> como entregables del proyecto algunos de los servicios diseñados y usados más frecuentemente. El código de estos servicios es utilizado por el resto de miembros del equipo para otras tareas de la aplicación, como puede ser la presentación de los datos en la interfaz web.</p>
<p>El pipeline que vamos a diseñar es posible gracias a la factorización en módulos de la aplicación y a la sencillez y versatilidad del modelo relacional de datos. Los servicios que ahora implementamos abstraen al resto del equipo de la funcionalidad subyacente y me permiten crear diferentes interfaces con propósitos distintos. Son muy importantes, ya que nos acercan al flujo de trabajo de integración continua que estamos buscando.</p>
<p>Por otro lado, tenemos métodos más clásicos en los que hacemos uso de las entidades registradas para obtener valores concretos. La siguiente función es una de las más usadas debido a la integración directa con el proceso de descarga de imágenes satelitales del cultivo. Fijémonos en cómo utilizamos las entidades creadas anteriormente para acceder a la información de la BD, el ORM subyacente nos abstrae de otras consultas complejas que podríamos hacer en lenguajes como SQL.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">get_indice_func</span><span class="p">(</span><span class="n">parcela</span><span class="p">,</span> <span class="n">indice_p</span><span class="p">,</span> <span class="n">fecha_p</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">filtro</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Método que encapsula el uso de una función agregada junto con un filtro &quot;&quot;&quot;</span>

    <span class="n">indice_p</span> <span class="o">=</span> <span class="n">Indice</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nombre</span><span class="o">=</span><span class="n">indice_p</span><span class="p">)</span> 

    <span class="k">if</span> <span class="n">ParcelaIndices_Service</span><span class="o">.</span><span class="n">is_parcela_filter</span><span class="p">(</span><span class="n">parcela</span><span class="p">,</span> <span class="n">filtro</span><span class="p">):</span>

        <span class="n">pixels</span> <span class="o">=</span> <span class="n">parcela</span><span class="o">.</span><span class="n">get_pixeles</span><span class="p">()</span>

        <span class="n">indices_pixels</span> <span class="o">=</span> <span class="n">Mirar_Indice</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>

            <span class="n">pixel__in</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">,</span> 
            <span class="n">indice</span> <span class="o">=</span> <span class="n">indice_p</span><span class="p">,</span> 
            <span class="n">fecha</span> <span class="o">=</span> <span class="n">fecha_p</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">ParcelaIndices_Service</span><span class="o">.</span><span class="n">get_indice_filter</span><span class="p">(</span><span class="n">indices_pixels</span><span class="p">,</span> <span class="n">filtro</span><span class="p">):</span>

            <span class="n">array_valores</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices_pixels</span><span class="o">.</span><span class="n">values_list</span><span class="p">(</span><span class="s1">&#39;valor&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">array_valores</span><span class="p">)</span>
</code></pre></div></div><p style="page-break-after: always;">&nbsp;</p><div id=PIPELINE><h2>8 PIPELINE</h2><div id=Transformación_de_datos><h3>8.1 Transformación de datos</h3><p>Una vez tenemos un modelo que soporta las principales entidades del dominio agronómico que necesitamos, procedemos a cargar la información proveniente de distintas fuentes en la BD bajo sus correspondientes entidades y con las relaciones necesarias para las consultas. Para esta carga vamos a utilizar un pipeline de datos; veamos a qué nos referimos.</p>
<p>Es importante diferenciar qué tipo de estructura estamos construyendo. Existen actualmente varias arquitecturas para 'pipelines', como pueden ser ETLs u otras. Para la correcta carga y transformación de datos no utilizaremos ninguna de estas arquitecturas, sino que diseñaremos los bloques necesarios en cada paso para poblar nuestra base de datos. Este proceso puede entenderse como una canalización de datos, en la que recibimos información en diferentes fuentes y la dotamos de contexto dentro de la BD.</p>
<B>Canalización de datos</B>
<p>Una canalización de datos hace referencia a los pasos necesarios para mover datos del sistema de origen al sistema de destino. Estos pasos incluyen copiar datos, transferirlos desde una ubicación a otra y combinarlos con otras fuentes de datos. El objetivo principal de una canalización de datos es garantizar que todos estos pasos se produzcan de forma coherente con todos los datos.</p>
<p>En el apartado anterior hemos visto cómo se ha diseñado el modelo de datos. Ahora nos centramos en los pequeños pasos de carga que vamos a dar para que los datos agronómicos de clientes e imágenes satelitales  persistan en dicho modelo. Valoramos la identificación de unidades atómicas de persistencia de información que puedan ejecutarse reiteradamente. Es decir, buscaremos acotar pequeños procesos de carga que puedan ejecutarse en varios puntos dependiendo del volumen de datos de clientes que maneje el equipo en un momento dado.</p>
<B>Procesos de una canalización</B>
<p>Identificamos tres conceptos que definen la canalización de datos que vamos a llevar a cabo y exponemos qué hace el <em>pipeline</em> de nuestra aplicación en cada uno de ellos.  </p>
<ul>
<li>
<p>Data Ingestion: diseñamos bloques atómicos de carga que almacenan datos de fuentes diferentes en la base de datos de la aplicación.</p>
</li>
<li>
<p>Data Transformation: utilizamos los bloques de carga para almacenar los datos en nuestro modelo de Django.</p>
</li>
<li>
<p>Data Storage: almacenamos los datos en el modelo a través de Django, manteniendo una base de datos relacional en la máquina en la que se encuentra la aplicación.</p>
</li>
</ul>
<p>Como hemos dicho, hay varias formas de realizar este proceso de canalización; en nuestro caso identificaremos los bloques y diseñaremos el proceso casi de forma manual, para que se ajuste con exactitud a lo que queremos hacer. En el siguiente punto exponemos la tecnología subyacente que utilizaremos para ello. </p></div><div id=Design_pattern><h3>8.2 Design pattern</h3><p>En ingeniería de software, un <strong>patrón de diseño</strong> es una solución general y reutilizable para un problema común dentro de un contexto dado. El término "pipeline" puede hacer referencia a diferentes soluciones y contextos. De momento vamos a centrarnos en su aplicación como patrón de diseño ya que en nuestra aplicación se está utilizando como tal.</p>
<p><strong>Podemos definir un pipeline como una cadena de elementos de procesamiento (procesos, subprocesos, rutinas, funciones, etc.) dispuestos de modo que la salida de cada elemento sea la entrada del siguiente; el nombre hace referencia al flujo de una o varias tuberías.</strong></p>
<p>En nuestro caso vamos a utilizar la arquitectura de comandos que proporciona Django para diseñar los procesos de transformación de datos que van a poblar la base de datos. La definición y reutilización del proceso de población es muy importante debido a la forma de trabajo que tiene la empresa con diferentes clientes. Dependiendo del cliente, se prepara una copia de la aplicación para trabajar con sus datos; por ello, una vez definidas las unidades atómicas del proceso de carga de datos, se podrán diseñar diferentes pipelines para cada cliente. Para este trabajo nos conformaremos con el diseño y la implementación de un proceso general, pero manteniendo la idea de que pueda ser escalado más adelante.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">django.core.management.base</span> <span class="kn">import</span> <span class="n">BaseCommand</span>

<span class="k">class</span> <span class="nc">Command</span><span class="p">(</span><span class="n">BaseCommand</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">handle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>

        <span class="c1"># now do the things that you want with your models here</span>
</code></pre></div>

<p>Las líneas de código anteriores hacen referencia a una implementación concreta del patrón mencionado.  Fijándonos en la siguiente figura, la clase <strong>Command</strong> sería el handler; el método <strong>handle</strong> corresponde con <em>handleRequest</em> del esquema. Los próximos scripts que creemos serán los clientes de estas clases. Destacaremos que la implementación de Django de este patrón es un poco más compleja porque los comandos que encapsulan la funcionalidad permiten tomar diferentes parámetros. </p>
<p>
<figure><img src="figures/pipeline_pattern.PNG" /><figcaption>Pipeline design pattern, diagrama de clases para exponer cómo vamos a utilizar los bloques de carga creamos.</figcaption>
</figure>
</p>
<p>Con este patrón desarrollamos la infraestructura necesaria para cargar los datos en el modelo. Cada comando representa un proceso de carga de datos, el cual se puede componer posteriormente dentro de un proceso más complejo. Cada unidad de carga se comporta como un filtro que añade de forma ordenada la información al modelo de datos, enlazando las entidades con sus datos correspondientes. Utilizaremos estas unidades para generar diferentes tuberías que permitan dejar varias instancias de la aplicación en estados diferentes.</p>
<p>Para AGRAI hace falta transformar los datos de índices vegetativos que maneja el equipo en información ordenada que llegue al modelo de datos desarrollado anteriormente. A continuación explicamos el flujo de procesos de carga más utilizado.</p>
<p>Los datos principalmente provienen de <em>Qgis</em>, software para trabajar con información georreferenciada. El equipo pre-procesa la información sobre los índices vegetativos y da valores a los píxeles mediante dicho software. La principal función de este trabajo es dar sentido a esa información, guardando los datos tomados junto con sus relaciones con el parcelario físico.</p>
<p>'<img alt="" src="mermaid\output_3.png" />'</p>
<p>La información de los píxeles tiene que enlazarse con los datos de parcelas y cultivos. Cuando obtenemos los índices vegetativos solo contemplamos la información sobre la geometría de la parcela, no sabemos nada más. Esta información tiene que almacenarse junto con el cultivo, el estado fenológico, los datos físicos de la parcela, etc. En la siguiente tabla explicamos cada uno de los <a href="https://github.com/alesteba/tfg/tree/main/entregables/pipeline">scripts</a> que conforman los procesos del pipeline.</p>
<table>
<thead>
<tr>
<th style="text-align: left;">SCRIPT</th>
<th style="text-align: center;">TAREA</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">load_qgis</td>
<td style="text-align: center;">Extrae la información geométrica de cada pixel proveniente de "qgis" e inserta dicha información en las tablas de "parcela" y "pixel" de la BD.</td>
</tr>
<tr>
<td style="text-align: left;">load_parcela</td>
<td style="text-align: center;">Lee de un excel información fisca sobre las parcelas e inserta los datos en la BD.</td>
</tr>
<tr>
<td style="text-align: left;">load_cultivos</td>
<td style="text-align: center;">Lee de un excel información sobre cultivos con sus variedades e inserta los datos en la BD.</td>
</tr>
<tr>
<td style="text-align: left;">download_img</td>
<td style="text-align: center;">Usa uno de los módulos desarrollado por el equipo para descargar índices vegetativos a partir de imágenes satelitales. No almacen nada directamente, devuelve un dataframe con los datos descargados.</td>
</tr>
<tr>
<td style="text-align: left;">load_indice</td>
<td style="text-align: center;">Integra la información de índices descargada en el paso anterior en la tabla de "pixel" de la BD.</td>
</tr>
<tr>
<td style="text-align: left;">load_range</td>
<td style="text-align: center;">Utiliza el script anterior para cargar varios índices.</td>
</tr>
<tr>
<td style="text-align: left;">create_view</td>
<td style="text-align: center;">Construye la vista minable de la que hablaremos en el siguiente punto.</td>
</tr>
<tr>
<td style="text-align: left;">create_model</td>
<td style="text-align: center;">Busca y entrena el mejor modelo IA posible sobre la vista minable anterior.</td>
</tr>
<tr>
<td style="text-align: left;">predict_model</td>
<td style="text-align: center;">Utiliza el modelo entrenado para predecir sobre los datos de prueba que contiene la vista minable.</td>
</tr>
</tbody>
</table>
<p>Para entender detalladamente qué hacen los scripts de carga de índices tenemos que explicar algunos de los procesos de automatización de los que hacemos uso. </p>
<p>Estos scripts nos permiten crear el flujo necesario para que la aplicación procese la información y termine en un estado consistente. Parte del proceso necesita ser automatizado y ejecutado reiteradamente, añadiendo los datos a la BD y relacionándolos adecuadamente. En nuestro contexto agronómico, es la descarga de índices la parte del proceso que necesita ser automatizada, mientras que los datos de las parcelas y cultivos y la información geoespacial se pueden cargar directamente en el despliegue de la aplicación. </p>
<p>Con esta estructura de tuberías lista, podemos reutilizar cualquier parte del proceso. Un planificador de tareas nos ayuda a establecer el tiempo que tiene que transcurrir entre las descargas.  Se ha utilizado el scheduler por defecto del framework de Django que estamos utilizando para esta gestión de tiempos y descarga,</p>
<p>Finalmente, para realizar pruebas y exponer el proceso en esta memoria, Jenkins nos permite ejecutar de forma ordenada el flujo completo del pipeline mediante infraestructura como código. El resto de tuberías que se utilzian en el proyecto tienen una forma similar y hacen el mismo uso de los comandos de Django que hemos explicado.</p>
<p>Por último, este patrón nos permite ejecutar comandos de forma asíncrona y gestionar los procesos con un planificador. Actualmente, aunque el tiempo de carga es alto, podemos asumir una carga lenta. Pero es este mismo patrón de diseño el que nos puede permitir a futuro la carga asíncrona de los datos en cada una de los componentes que lo forman.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">run</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DATA</span><span class="p">,</span> <span class="n">INDICES</span><span class="p">):</span>

    <span class="k">for</span> <span class="n">indice</span> <span class="ow">in</span> <span class="n">INDICES</span><span class="p">:</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">DATA</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">drop_cols</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">indice</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_name</span><span class="p">:</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">col_name</span> <span class="o">==</span> <span class="s1">&#39;ID&#39;</span><span class="p">):</span>

            <span class="k">continue</span>

            <span class="n">drop_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>

        <span class="n">df1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">drop_cols</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">call_command</span><span class="p">(</span><span class="s1">&#39;4-load_indice&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">df1</span><span class="p">,</span> <span class="n">indice</span><span class="o">=</span><span class="n">indice</span><span class="p">)</span>
</code></pre></div>

<p>Adjuntamos en los entregables los <a href="https://github.com/alesteba/tfg/tree/main/entregables/pipeline">scripts</a> que forman este proceso de almacenamiento de datos. </p></div><div id=Vista_minable><h3>8.3 Vista minable</h3><p>Hasta este punto habíamos insertado en la base da datos la información que provenía de diferentes fuentes. Hemos dotado de consistencia y relación a los datos y se ha creado un sistema con capacidad para hacer consultas sobre estos de forma ordenada y sencilla.</p>
<p>Ahora, fuera de la estructura de comandos de <em>Django</em> y utilizando el entorno virtual creado y los cuadernos integrados en la aplicación, escribimos el algoritmo para extraer los datos y dar la forma necesaria para los siguientes pasos.</p>
<p>El código que mostramos en este apartado corresponde con la generación de la vista tabulada con la que vamos a crear el modelo de producción de cultivo. Ahora realizamos el proceso inverso a la persistencia de datos que hemos realizado hasta este punto. Utilizamos la información y sus relaciones perisitidas en la base de datos de nuestro sistema para generar la vista minable que necesita el modelo predictivo. </p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">statistic_indices</span><span class="p">(</span><span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ndvi&#39;</span><span class="p">,</span> <span class="s1">&#39;ndre&#39;</span><span class="p">],</span> <span class="n">func</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">):</span>

    <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

    <span class="n">col_ids</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Parcela</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>

        <span class="n">col_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>

    <span class="n">df</span><span class="p">[</span><span class="s1">&#39;IDX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">col_ids</span>

    <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>

        <span class="n">indice_p</span> <span class="o">=</span> <span class="n">Indice</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nombre</span><span class="o">=</span><span class="n">ind</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fecha</span> <span class="ow">in</span> <span class="n">fechas</span><span class="p">:</span> 

            <span class="n">col_data</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># por cada iteración creamos una fila en el df:</span>

            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">Parcela</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>

                <span class="c1"># la media de todos sus índices</span>

                <span class="n">p_indices</span> <span class="o">=</span> <span class="n">Pixel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">parcela</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

                <span class="n">list_values</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">p_itr</span> <span class="ow">in</span> <span class="n">p_indices</span><span class="p">:</span>

                    <span class="n">qs</span> <span class="o">=</span>  <span class="n">Mirar_Indice</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>

                        <span class="n">pixel</span> <span class="o">=</span> <span class="n">p_itr</span><span class="p">,</span> 
                        <span class="n">indice</span> <span class="o">=</span> <span class="n">indice_p</span><span class="p">,</span> 
                        <span class="n">fecha</span> <span class="o">=</span> <span class="n">fecha</span> <span class="c1"># fecha para la columna:</span>
                    <span class="p">)</span>

                    <span class="kn">import</span> <span class="nn">math</span>

                    <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">qs</span><span class="o">.</span><span class="n">valor</span><span class="p">)</span> <span class="p">):</span>

                        <span class="n">list_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">qs</span><span class="o">.</span><span class="n">valor</span><span class="p">)</span>

                <span class="c1"># estadistico:añadir columna</span>

                <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">list_values</span><span class="p">)</span>

                <span class="n">col_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

            <span class="n">df</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">ind</span> <span class="o">+</span><span class="s1">&#39;_&#39;</span> <span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">fecha</span><span class="p">)]</span> <span class="o">=</span> <span class="n">col_data</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre></div>

<B>Selección de features</B>
<p>El diseño de la vista minable es complicado; para ello trabajo con el equipo seleccionando los campos de la BD más importantes que formarán la tabla.  Nos centramos principalmente en los índices vegetativos registrados en diferentes fechas. </p>
<p>Para poder predecir la producción de cultivo, incluimos en la vista varios estadísticos, como la media y el sumatorio para cada índice en cuatro fechas representativas de la evolución de este. El diseño de esta estructura proviene de un estudio previo realizado por el equipo en el que se ha concluido que ciertos estadísticos en unas fechas calibradas funcionan bien para predecir la producción. </p>
<p>Hablábamos anteriormente de entornos virtuales, por el momento la aplicación utiliza un solo entorno virtual Python, pero este punto del trabajo podría hacer uso de un entorno separado con las librerías de ciencia de datos instaladas, de tal forma que separaríamos dos procesos importantes. Hay que destacar que en el trabajo me estoy encargando del proceso para hacer pruebas, pero serán diferentes miembros del equipo los que usen estas tecnologías: para que podamos seguir escalando a medida que evolucione la aplicación, estos miembros tienen que poder utilizar los entornos creados.</p>
<B>Variable Objetivo</B>
<p>Junto con los datos extraídos añadiremos la variable objetivo, "producción". Esta variable, aún sin almacenar en el modelo relacional, hace referencia a los kilos de producción de cada parcela en su cosecha, se obtiene a partir de históricos de campañas anteriores. A partir de ella, junto con las features anteriores, vamos a poder predecir la evolución del cultivo con precisión en estados concretos de su maduración. Se explica con detalle en el siguiente punto.</p></div><div id=Integración_continua><h3>8.4 Integración continua</h3><p>Una vez hemos identificado los pasos atómicos que queremos ejecutar de forma secuencial, utilizamos la herramienta de integración continua, Jenkins, para ejecutar estos pasos de forma ordenada y ver poco a poco el proceso. </p>
<p>El siguiente script reproduce el flujo de uso común de la aplicación desde su creación, pasando por todos los pasos de carga de datos en el modelo, hasta la vista minable sobre la cual se obtiene el modelo de producción de kg de cultivo. </p>
<p>La ejecución del siguiente pipeline tiene lugar tras lanzar la máquina Vagrant sobre la que corre el proyecto. En el comienzo de la memoria habíamos hablado de que dicha máquina se provisiona con los scripts necesarios para instalar las dependencias del proyecto. En este punto con la máquina en dicho estado, los primeros pasos del pipeline descargan la última versión estable del código del proyecto y crean un entorno virtual que hace uso del las librerías correctas. </p>
<p>Los siguientes pasos ejecutan uno a uno los comandos definidos anteriormente, cargando así en la base de datos los datos provenientes de las distintas fuentes (en este caso excels) y procesando su vista minable. El proceso se realiza de forma ordenada para las 25 parcelas de muestra con las que estamos trabajando, remarcamos que el proceso tiene una alta escalabilidad debido a que podemos reproducir aquellos 'stages' necesarios en los momentos que nos interese. Es decir, podemos comenzar con un pipeline para insertar la información de 25 parcelas, pero posteriormente podríamos añadir más pasos a medida que dispongamos de más información. Por otra parte, la infraestructura como código que conseguimos posibilita definir el flujo concreto que un cliente puede tener con la aplicación. </p>
<div class="codehilite"><pre><span></span><code><span class="n">pipeline</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">agent</span><span class="w"> </span><span class="n">any</span><span class="w"></span>

<span class="w">    </span><span class="n">stages</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;git&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">git</span><span class="w"> </span><span class="n">url</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;/home/vagrant/agrai/.git&#39;</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;env&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 -m venv ./tfg_venv&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;. ./tfg_venv/bin/activate&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;pip install -r ./unix-dep/requirements.txt&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;pip install --upgrade numpy&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;migrate&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">           </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py makemigrations core&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py migrate&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py flush --no-input&#39;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w">    </span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;sources&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;python3.10 manage.py 1-load-qgis </span><span class="w"></span>
<span class="s2">                    --parcelas &quot;data/parcelas/25/parcelas.shp&quot; </span><span class="w"></span>
<span class="s2">                    --pixels &quot;data/parcelas/25/pixeles.shp&quot; &quot;&quot;&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;python3.10 manage.py 2-load-parcela-data </span><span class="w"></span>
<span class="s2">                    -xls &quot;data/excels/datos-test-2.xls&quot; &quot;&quot;&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;python3.10 manage.py 3-load-cultivos </span><span class="w"></span>
<span class="s2">                    -xls &quot;data/excels/datos-test-2.xls&quot; &quot;&quot;&quot;</span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;sentinel&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">sh</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;python3.10 manage.py 4-download_img </span><span class="w"></span>
<span class="s2">                    -a &quot;20220601&quot; </span><span class="w"></span>
<span class="s2">                    -b &quot;20220701&quot; </span><span class="w"></span>
<span class="s2">                    -p &quot;data/parcelas/25/pixeles.shp&quot; </span><span class="w"></span>
<span class="s2">                    -i ndvi ndre&quot;&quot;&quot;</span><span class="w"> </span><span class="p">)</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;indices&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py 5-load_range </span>
<span class="w">                                        </span><span class="o">-</span><span class="n">i</span><span class="w"> </span><span class="n">ndvi</span><span class="w"> </span><span class="n">ndre</span><span class="w"> </span><span class="s1">&#39;) } }</span>

<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;view&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py 6-create-view&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;train&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py 7-create-mode&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="n">stage</span><span class="p">(</span><span class="s1">&#39;predict&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">sh</span><span class="p">(</span><span class="s1">&#39;python3.10 manage.py 8-predict-model&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Además de este último, podemos crear varios entornos con tuberías diferentes que den como resultado bases de datos con estados distintos. Como mencionábamos anteriormente, esto es muy útil debido al funcionamiento del equipo en relación con el procesamiento de datos con varios clientes. La aplicación puede trabajar con instancias diferentes de la misma base de datos dependiendo del proyecto en el que se encuentre; por ejemplo, la misma instancia de la BD sirve tanto para una bodega con variedades de vino como para una cooperativa que contempla varios cultivos como guisantes, olivas, peras, etc. Por ello, definir scripts como el anterior utilizando los mismos comandos con distintas fuentes de datos es una forma clara y ordenada de automatizar los procesos.</p>
<p>
<figure><img src="figures/pipeline.png" /><figcaption>Ejecución del pipeline implementado desde la herramienta de integración continua Jenkins</figcaption>
</figure>
</p>
<p>Por último, mencionar que en los últimos pasos del pipeline se entrena el mejor modelo y se predice a modo de ejemplo la cantidad de kg de cultivo que van a ser cosechados para las 25 parcelas con las que estamos trabajando.</p></div><p style="page-break-after: always;">&nbsp;</p><div id=MODELO_IA><h2>9 MODELO IA</h2><div id=Preprocesamiento><h3>9.1 Preprocesamiento</h3><p>Como los datos con los que trabajamos en los cuadernos provienen de una base de datos estructurada y previamente estudiada, no va a hacer falta un paso de preprocesamiento previo. De todas formas, sí que intentaremos que los datos de producción con los que vamos a predecir estén normalizados y que se haya hecho una búsqueda previa de 'outliers'.</p>
<p>Buscamos un modelo de regresión para el número de Kg de cultivo en cada parcela. Aunque los datos son representativos de un parcelario pequeño, diseñaremos los cuadernos para automatizar la búsqueda del mejor modelo con cualquier volumen de datos que podamos necesitar más adelante.</p>
<p>El rango de valores para la mayoría de los índices que obtenemos va de -1 a 1. Los datos de índices negativos que llegan a la vista se pueden considerar como 'outliers'. Esto es debido a que, si los índices provienen de una imagen con nubes, no se diferencian los colores del terreno y el índice acaba teniendo un valor muy malo. Para evitar valores corruptos eliminaremos los índices que provengan de la toma de la imagen en una fecha en la que había nubes.</p>
<p>
<figure><img src="figures/nubes.png" /><figcaption>Imagen satelital con nubes para indicar cómo afectan a los índices vegetativos calculados en la vista minable.</figcaption>
</figure>
</p>
<p>El <a href="https://github.com/alesteba/tfg/tree/main/entregables">siguiente repositorio</a> contiene los cuadernos necesarios para la gestión y automatización de los modelos de producción generados a partir los datos de las 25 parcelas estudiadas. Recordamos que estamos pensando en escribir el código necesario para automatizar en la medida de lo posible la búsqueda del mejor modelo de producción, de tal forma que cuando el sistema contemple un mayor número de parcelas, la ejecución de los cuadernos nos siga generando el mejor modelo de producción posible.</p></div><div id=Regresión><h3>9.2 Regresión</h3><p>La vista minable que hemos obtenido representa los datos necesarios para crear un modelo de producción para el cultivo. El <a href="https://github.com/alesteba/tfg/tree/main/entregables">próximo entregable</a> es el desarrollo de uno o varios cuadernos de jupyter con modelos de inteligencia artificial para la tabla anterior.</p>
<p>
<figure><img src="figures/view-capture.png" /><figcaption>Tabla con la vista minable calculada para un rango de fechas concretas.</figcaption>
</figure>
</p>
<p>En el punto en el que estamos, podemos pensar en las múltiples vistas que se pueden generar a partir de los datos persistidos en la BD. Desde aquí desarrollaremos la automatización de la búsqueda del mejor modelo posible para la vista anterior, pero siempre teniendo en cuenta que a partir de los datos almacenados podemos predecir muchos otros valores, no solo la producción de un cultivo. </p>
<p>Resaltamos esta idea debido a que es el punto más fuerte del trabajo realizado. La arquitectura obtenida para la aplicación nos permite generar diferentes vistas con el objetivo de utilizar la información en diversos estudios. Los índices vegetativos y la información almacenada sobre de los cultivos se pueden presentar en el formato necesario que el estudio requiera. </p>
<p>Por último, deberíamos poder utilizar este modelo obtenido dentro de la arquitectura de la aplicación para predecir, cómo evolucionan los cultivos que se están monitorizando. El punto en el que se encuentra la arquitectura soporta casi de forma directa la inclusión de las predicciones de la aplicación.</p></div><div id=Mejor_modelo><h3>9.3 Mejor modelo</h3><p>Tras conseguir los datos con la forma correspondiente, exponemos los modelos de inteligencia artificial que vamos a utilizar para buscar el mejor modelo de producción de cultivo (kg) posible.</p>
<p>El problema que estamos buscando resolver es un problema de regresión, en el que conocemos la variable objetivo por el estudio de campañas anteriores. Los clientes, en este caso agricultores, quieren poder predecir cuántos kg de cultivo van a poder cosechar al final de la temporada (septiembre), o en estados previos de maduración (enero).</p>
<p>Los cuadernos que conforman el entregable contienen código que busca el mejor modelo posible para los datos importados con los índices y sus estadísticos. Los índices vegetativos registrados en diferentes fechas, junto con la variable de producción de campañas anteriores, tienen que poder predecir con precisión la campaña actual.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># drop columns with negative mean.</span>

<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>

    <span class="n">df2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">df2</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>Antes de ejecutar código para los modelos, analizamos las relaciones entre las columnas y hacemos estudios de correlación y análisis de componentes principales, para ver si algunos datos de fechas que han llegado a este punto no añaden valor a la información que queremos predecir. Recordemos que puede que lleguen índices provenientes de imágenes tomadas entre nubes y entonces la información empeora el modelo.</p>
<p>Un análisis de componentes principales y la observación de las mejores columnas son el siguiente paso a la limpieza de columnas que se ha realizado en el preprocesamiento.</p>
<div class="codehilite"><pre><span></span><code><span class="n">rfe</span> <span class="o">=</span> <span class="n">RFE</span><span class="p">(</span><span class="n">estimator</span><span class="o">=</span><span class="n">DecisionTreeRegressor</span><span class="p">(),</span> <span class="n">n_features_to_select</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span> <span class="n">Â</span> 
<span class="n">model</span> <span class="o">=</span> <span class="n">DecisionTreeRegressor</span><span class="p">()</span>
<span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;s&#39;</span><span class="p">,</span><span class="n">rfe</span><span class="p">),(</span><span class="s1">&#39;m&#39;</span><span class="p">,</span><span class="n">model</span><span class="p">)])</span>

<span class="n">cv</span> <span class="o">=</span> <span class="n">RepeatedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">n_scores</span> <span class="o">=</span> <span class="n">cross_val_score</span><span class="p">(</span><span class="n">pipeline</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">&#39;neg_mean_absolute_error&#39;</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span><span class="n">cv</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;MAE: </span><span class="si">%.3f</span><span class="s1"> (</span><span class="si">%.3f</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">mean</span><span class="p">(</span><span class="n">n_scores</span><span class="p">),</span> <span class="n">std</span><span class="p">(</span><span class="n">n_scores</span><span class="p">)))</span>
</code></pre></div>

<p>Para la variable objetivo de producción también hacemos un pequeño análisis. Queremos ver si esta contiene outilers, para ello analizamos la distribución y seleccionamos aquellos valores que se alejan mucho de la media y desviación típica de la muestra. Es importante que los datos con los que vamos a predecir estén limpios para que el modelo obtenga una buena métrica, como puede ser el "mean absolute error", MAE, puntuación para problemas de regresión en el que el resultado está contemplado en las unidades de la variable analizada.</p>
<p>Una vez hemos analizado los datos y hemos limpiado los valores erróneos de los índices, procedemos a probar aquellos modelos de inteligencia artificial que mejor puedan predecir este valor de kg de producción. Los modelos que probamos son los siguientes.</p>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>MODEL</th>
      <th>PARAMS</th>
      <th>MAE</th>
      <th>MSE</th>
      <th>RMSE</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>RandomForestRegressor</td>
      <td>{'rf__max_depth': 7, 'rf__max_features': 'sqrt', 'rf__n_estimators': 5, 'rf__random_state': 42}</td>
      <td>2282.013333</td>
      <td>1.464411e+07</td>
      <td>3826.762121</td>
    </tr>
    <tr>
      <th>0</th>
      <td>ElasticNet</td>
      <td>{'en__alpha': 10, 'en__l1_ratio': 0.7000000000000001, 'en__max_iter': 5}</td>
      <td>4668.784757</td>
      <td>4.217480e+07</td>
      <td>6494.212821</td>
    </tr>
    <tr>
      <th>4</th>
      <td>KNeighborsRegressor</td>
      <td>{'knn__metric': 'manhattan', 'knn__n_neighbors': 11, 'knn__weights': 'uniform'}</td>
      <td>5109.534545</td>
      <td>4.310770e+07</td>
      <td>6565.645200</td>
    </tr>
    <tr>
      <th>3</th>
      <td>MLPRegressor</td>
      <td>{'mlpr__activation': 'tanh', 'mlpr__alpha': 0.05, 'mlpr__hidden_layer_sizes': (100, 50, 30), 'mlpr__learning_rate': 'adaptive', 'mlpr__max_iter': 50, 'mlpr__solver': 'sgd'}</td>
      <td>4599.475956</td>
      <td>4.323998e+07</td>
      <td>6575.711553</td>
    </tr>
    <tr>
      <th>1</th>
      <td>SVR</td>
      <td>{'svr__C': 5.0, 'svr__gamma': 0.01, 'svr__kernel': 'linear'}</td>
      <td>4129.801479</td>
      <td>4.749271e+07</td>
      <td>6891.495313</td>
    </tr>
  </tbody>
</table>

<p>La tabla anterior muestra ciertas métricas para los algoritmos probados. Al ordenar la tabla por el RMSE vemos qué algoritmo predice un poco mejor y observamos aquellos hiperparámetros que mejor score obtienen.</p>
<div class="codehilite"><pre><span></span><code><span class="n">df_sorted</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;RMSE&#39;</span><span class="p">,</span> <span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">na_position</span><span class="o">=</span><span class="s1">&#39;first&#39;</span><span class="p">);</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">best_models</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df_sorted</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

    <span class="n">model_str</span><span class="p">,</span> <span class="n">model_prm</span><span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;MODEL&quot;</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;PARAMS&quot;</span><span class="p">]</span>
    <span class="n">model_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="vm">__name__</span><span class="p">],</span> <span class="n">model_str</span><span class="p">)</span>
    <span class="n">rm_pre_parms</span> <span class="o">=</span> <span class="n">rm_dict_pre</span><span class="p">(</span><span class="n">model_prm</span><span class="p">)</span> <span class="c1"># modify dict keys</span>
    <span class="n">best_model</span> <span class="o">=</span> <span class="n">model_type</span><span class="p">(</span><span class="o">**</span><span class="n">rm_pre_parms</span><span class="p">)</span>
    <span class="n">best_models</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_model</span><span class="p">)</span>
</code></pre></div>

<div class="codehilite"><pre><span></span><code><span class="n">best_estimators</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">est</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">best_models</span><span class="p">):</span>

    <span class="n">best_estimators</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">est</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">est</span><span class="p">))</span>
</code></pre></div>

<p>Como cada modelo aporta un punto de vista diferente, vamos a utilizar los resultados obtenidos para generar un modelo ensemble que generalice las predicciones de los anteriores. Utilizaremos las métricas obtenidas para establecer el orden en el que construir un modelo 'stacking'. Como estimador final nos quedamos como el mejor modelo obtenido al ordenar la tabla anterior por el valor del RMSE obtenido para cada uno de ellos, es decir, el RandomForestRegressor.</p>
<div class="codehilite"><pre><span></span><code><span class="n">reg</span> <span class="o">=</span> <span class="n">StackingRegressor</span><span class="p">(</span>
        <span class="n">estimators</span><span class="o">=</span><span class="n">estimators</span><span class="p">,</span>
        <span class="n">final_estimator</span><span class="o">=</span><span class="n">estimators</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

<span class="n">reg</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="n">y_pred_e</span> <span class="o">=</span> <span class="n">reg</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>

<p>A continuación mostramos una gráfica para cada modelo en la que vemos la relación entre los valores actuales y los valores predichos por el modelo. Esta pequeña visualización nos permite ver si cada algoritmo sobreajusta a los datos de entrenamiento o realmente tiene el rango que necesitamos. El punto más interesante es el análisis del modelo 'stacking' en el que vemos que es capaz de inferir los estilos de los algoritmos anteriores.</p>
<p>
<figure><img src="figures/models-predictions.png" /><figcaption>Comparación de los algoritmos. Valores reales vs. los predichos por cada uno de los modelos utilizados.</figcaption>
</figure>
</p>
<p>Hemos analizado cada algoritmo con la intención de ver si modeliza correctamente nuestro problema de regresión, pero no es nuestro objetivo final que el modelo prediga con exactitud: solo queremos dejar automatizada una pequeña visualización de las relaciones entre los índices para así poder intuir qué modelo nos puede funcionar mejor. De hecho, los datos representativos con los que trabajamos nos impiden buscar un modelo real preciso.</p></div><div id=Predicciones><h3>9.4 Predicciones</h3><p>Nuestro último paso en el pipeline mostrado anteriormente es la capacidad para utilizar el modelo y predecir qué cantidad de kg se pueden cosechar cuando se pasa una nueva parcela al sistema. A continuación mostramos cómo el último 'stage' del pipeline utiliza el modelo que acabamos de entenar para predecir sobre la vista minable.</p>
<div class="codehilite"><pre><span></span><code><span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;script/finalized_model.sav&#39;</span>

<span class="n">df_x</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">&#39;script/view.csv&#39;</span><span class="p">)</span>

<span class="n">loaded_model</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>

<span class="n">y_pred_e</span> <span class="o">=</span> <span class="n">loaded_model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">df_x</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">y_pred_e</span><span class="p">)</span>
</code></pre></div>

<p>En este punto, deberíamos poder utilizar este modelo obtenido dentro de la arquitectura de la aplicación para predecir, cómo evolucionan los cultivos que se están monitorizando. El punto en el que se encuentra la arquitectura soporta casi de forma directa la inclusión de las predicciones de la aplicación.</p>
<p>
<figure><img src="figures/predict.png" /><figcaption>Predicción de la cantidad de Kg de cultivo que se va a cosechar. Resultado tras la ejecución del último 'stage' en el pipeline.</figcaption>
</figure>
</p></div><p style="page-break-after: always;">&nbsp;</p><div id=SEGUIMIENTO><h2>10 SEGUIMIENTO</h2><div id=Desviaciones><h3>10.1 Desviaciones</h3><p>El proyecto se ha desarrollado sin grandes cambios relativos a la planificación estipulada, pero a pesar de realizar la planificación del proyecto con su desglose en entregables y horas para los paquetes de trabajo, el tiempo de desarrollo ha diferido de la misma en algunas ocasiones, especialmente en la memoria.</p>
<p>El número de horas planificadas era de 300, las cuales se repartían en varias etapas marcadas  por los diversos puntos de control: planificación, análisis, infraestructura, diseño,  implementación, modelos y seguimiento y control.</p>
<p>No ha habido grandes desviaciones en cuanto a la planificación estipulada en el desglose de tareas. Sí que podemos remarcar que se han dedicado más horas a la redacción de la memoria y a algunas tareas secundarias relacionadas con esta, como pueden ser la integración de los diversos diagramas que apareceno la automatización en Github Actions. Podemos estimar entre 15 o 20 horas más para esta tarea sobre las 20 estimadas al principio.</p></div><div id=Memoria><h3>10.2 Memoria</h3><p>Esta memoria se incluye como un entregable del proyecto debido a las explicaciones y esquemas que contiene (principalmente para el modelo relacional). Para poder mejorar el flujo de trabajo, ciertos conceptos necesitan ser entendidos por los desarrolladores. La documentación aquí expuesta tiene un gran valor por el lenguaje ubicuo que implanta en el proyecto. </p>
<p>El documento se ha escrito como notas en <em>Markdown</em> por la facilidad que da para incluir fragmentos de código relativos al proyecto y poder explicar decisiones y conceptos. Para integrar los diagramas expuestos utilizamos tecnologías como <em>Mermaid</em>, que posibilita editar los diagramas directamente en el documento, algo totalmente necesario cuando estos modelos se modifican a medida que avanzamos.</p>
<p>Finalmente, exportamos las notas en el orden necesario para la memoria y renderizamos el documento en HTML. El fácil acceso al documento tiene bastante relevancia por el uso que el equipo puede darle al consultar la documentación, especialmente la del modelo relacional y los servicios.</p>
<p>Utilizamos algunas herramientas de integración continua como <em>Github Actions</em> para automatizar este proceso. En un primer lugar convertimos el grafo de notas Markdown a un documento HTML mediante un proceso recursivo que ordena las notas y genera así la memoria del proyecto. Además, el índice se crea a partir de los nombres de las notas y sus relaciones con las que están enlazadas.</p>
<p>
<figure><img src="figures/graph.png" /><figcaption>Imagen del grafo asociado a las notas en las que se ha escrito esta memoria.</figcaption>
</figure>
</p>
<p>El principal interés de que la redacción se realice de esta forma es que al comienzo del proyecto no había una idea clara de cómo se tenían que desarrollar los contenidos. Escribir un capítulo o tema en una nota es algo más sencillo (por lo tanto, se puede terminar) que pensar desde el principio dónde colocar esta sección que quiero escribir en la memoria. Utilizando Obsidian como gestor de las notas, podemos definir relaciones entre ellas simplemente conectando palabras claves, de esta forma conseguimos un esquema mental del proyecto visualizando el grafo generado. Finalmente, a medida que nos acercamos al cierre del proyecto, escribimos en un notebook una serie de algoritmos que nos permiten presentar el resultado de la memoria de la forma que deseamos. En ellos implementamos los pasos necesarios para transformar cada nota a HTML, integrar aquellos <em>snipets</em> de código que pueda contener, representar tablas y diagramas, etc. Muy importante, el grafo permite generar los niveles de indentación asociados a cada capítulo o sección del documento. A continuación, mostramos algunas de las funciones utilizadas en el cuaderno para obtener el resultado que está leyendo.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">rec_note_prcs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="s1">&#39;TFG&#39;</span><span class="p">,</span> <span class="n">ident</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; recursive note building &quot;&quot;&quot;</span>

    <span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span> <span class="o">+</span> <span class="s1">&#39;.0&#39;</span>

    <span class="n">neigh</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">start</span><span class="p">))</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>

        <span class="k">return</span> <span class="n">note_decorate</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">ident</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>

    <span class="n">end_doc</span> <span class="o">=</span>  <span class="n">note_decorate</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">ident</span><span class="p">)</span>

      <span class="k">for</span> <span class="n">con</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">:</span>

        <span class="n">ident</span> <span class="o">=</span> <span class="n">ident</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ident</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">end_doc</span> <span class="o">=</span> <span class="n">end_doc</span> <span class="o">+</span> <span class="n">rec_note_prcs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">con</span><span class="p">,</span> <span class="n">ident</span><span class="p">)</span>

      <span class="k">return</span> <span class="n">end_doc</span>
</code></pre></div>

<p>Estas celdas de código son parte del proceso de transformación de Markdown a HTML. Aunque existen librerías con funciones para realizar dicha transformación, necesitamos realizar un gran trabajo de procesado para que el documento enlace las notas en el orden correcto y se tengan en cuenta conceptos como la indentación en los distintos apartados. El grafo que conforman las notas pasa a una estructura de árbol en la que es fácil crear enlaces entre los puntos a los que pertenece cada nota.</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">mermaid_process</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot; transforms any mermaid diagrams to images in png format &quot;&quot;&quot;</span>

    <span class="k">global</span> <span class="n">parent_directory</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">&#39;```mermad(?s:.*?)```&#39;</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">return</span> <span class="n">text</span>

    <span class="n">sub_text</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="s1">&#39;```mermad&#39;</span><span class="p">):</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">mermaid_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parent_directory</span><span class="p">,</span> <span class="s2">&quot;mermad&quot;</span><span class="p">)</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
        <span class="s1">&#39;```mermad(?s:.*?)```&#39;</span><span class="p">,</span> 
        <span class="n">mmd_to_img</span><span class="p">(</span><span class="n">sub_text</span><span class="p">,</span> <span class="n">mermaid_dir</span><span class="p">)</span> <span class="p">,</span>
        <span class="n">text</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">mermaid_process</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div>

<p>Estas notas se encuentran en un repositorio separado al proyecto para poder así construir la memoria. Utilizamos <em>Github Actions</em> para definir las acciones necesarias cuando se realicen cambios en el repositorio, es decir, a medida que escribimos en las notas. En primer lugar, queremos conseguir que el documento se renderice al hacer un <em>commit</em> en el repositorio y se publique posteriormente dicha memoria en una pequeña web bajo el dominio asociado a nuestro usuario de <em>Github Pages</em> (https://alesteba.github.io/tfg/). En segundo lugar, una vez tenemos publicada la memoria, una segunda acción convertirá el código HTML asociado al documento en el archivo PDF que está leyendo actualmente. </p>
<div class="codehilite"><pre><span></span><code><span class="w">  </span><span class="nt">build_notes</span><span class="p">:</span><span class="w"></span>

<span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Building web notes from graph</span><span class="w"></span>
<span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span><span class="w"></span>

<span class="w">    </span><span class="nt">steps</span><span class="p">:</span><span class="w"></span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Checkout</span><span class="w"></span>
<span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/checkout@v3</span><span class="w"></span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Setup Python</span><span class="w"></span>
<span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/setup-python@v3</span><span class="w"></span>
<span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w"></span>
<span class="w">          </span><span class="nt">python-version</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;3.9&#39;</span><span class="w"></span>
<span class="w">          </span><span class="nt">cache</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;pip&#39;</span><span class="w">      </span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Install Dependencies</span><span class="w"></span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">pip install -r requirements.txt</span><span class="w">   </span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Install Jupyter</span><span class="w"></span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">sudo -H pip install jupyter</span><span class="w"></span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Install Mermaid Converter</span><span class="w"></span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span><span class="w"></span>
<span class="w">          </span><span class="no">npm install -g @mermaid-js/mermaid-cli</span><span class="w"></span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Run Script and Build Notes</span><span class="w"></span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">|</span><span class="w"></span>
<span class="w">          </span><span class="no">cd _k.pcs.zen/</span><span class="w"></span>
<span class="w">          </span><span class="no">jupyter nbconvert --to script ./automate_md.ipynb</span><span class="w"></span>
<span class="w">          </span><span class="no">python ./automate_md.py      </span><span class="w"></span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Pushes to another repository</span><span class="w"></span>
<span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">cpina/github-action-push-to-another-repository@main</span><span class="w"></span>
<span class="w">        </span><span class="nt">env</span><span class="p">:</span><span class="w"></span>
<span class="w">          </span><span class="nt">API_TOKEN_GITHUB</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">${{ secrets.API_TOKEN_GITHUB }}</span><span class="w"></span>
<span class="w">        </span><span class="nt">with</span><span class="p">:</span><span class="w"></span>
<span class="w">          </span><span class="nt">source-directory</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;_k.pcs.zen/publish&#39;</span><span class="w"></span>
<span class="w">          </span><span class="nt">destination-github-username</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;alesteba&#39;</span><span class="w"></span>
<span class="w">          </span><span class="nt">destination-repository-name</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;tfg&#39;</span><span class="w"></span>
<span class="w">          </span><span class="nt">user-email</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">alesteba@unirioja.es</span><span class="w"></span>
<span class="w">          </span><span class="nt">target-branch</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">main</span><span class="w"></span>
</code></pre></div>

<p>El código anterior se corresponde con la infraestructura como código necesaria para transformar las notas de Markdown al documento en HTML. Como podemos observar en los pasos se utiliza una máquina Ubuntu en la que se instalan librerías necesarias para transformar los diagramas en imágenes y poder trabajar con cuadernos Jupyter. Posteriormente, se transforma el cuaderno con el código de conversión de las notas en un único script, se ejecuta y se publican los resultados en otro repositorio diferente, el cual mediante <em>Github Pages</em> crea la página HTML correspondiente con la memoria final. </p>
<p>
<figure><img src="figures/github-actions.png" /><figcaption>Ejemplo construcción de la memoria desde Github Actions.</figcaption>
</figure>
</p></div><p style="page-break-after: always;">&nbsp;</p><div id=CONCLUSIONES><h2>11 CONCLUSIONES</h2><p>Este trabajo se ha centrado en el desarrollo de un proceso de automatización que permite la integración continua del flujo de trabajo del equipo para una aplicación de gestión agronómica. Hemos pasado por casi todas las etapas de diseño e implementación, además de la final inclusión de los modelos predictivos para la producción de cultivo.</p>
<p>Durante el proceso hemos influido en los principales bloques de diseño e implementación relativos a la arquitectura de la aplicación, pasando por la infraestructura, los modelos de datos, la carga de estos datos, y la búsqueda de modelos predictivos a partir de ellos. Acorde al alcance planteado, hemos llegado satisfactoriamente a todos los puntos estipulados; recodamos estos puntos:</p>
<ul>
<li>Obtenemos un script de creación para el entorno necesario.</li>
<li>Diseñamos un modelo relacional de datos que permita un rápido escalado de la aplicación.</li>
<li>Automatizamos el proceso de trasformación de los datos mediante el diseño de un pipeline.</li>
<li>Diseñamos un algoritmo que exporte la vista minable necesaria para predecir la producción.</li>
<li>Utilizamos técnicas de lA para entrenar el mejor modelo de regresión para la producción anterior.</li>
<li>Implementamos el modelo para predecir nuevos valores que no han sido usados en el entrenamiento.</li>
</ul>
<p>Para finalizar, volvemos a los conceptos de los procesos 'lean' que mencionábamos al principio. La fácil comprensión que permiten los esquemas de datos aquí planteados dotan al equipo de trabajo del lenguaje ubicuo necesario para que el software pueda crecer y ser escalado, evitando bloqueos por falta de comprensión. El lenguaje que maneja el equipo está directamente relacionado con su buen funcionamiento y garantiza el proceso de  optimización continua. Los artefactos obtenidos y la explicación de los modelos quedan así como documentación interna que debe ser mantenida al mismo nivel de importancia que el software que la implementa. </p>
<p>'<img alt="" src="mermaid\output_4.png" />'</p>
<p>En cuanto a la aplicación, se ha conseguido terminar con un producto funcional que cumple con los requisitos planteados. El proceso de arquitectura conseguido facilita el uso de múltiples datos provenientes de las fuentes estudiadas. El esquema de datos relacional implementado soporta la carga de los índices vegetativos, así como el resto de información relativa al parcelario. Los bloques atómicos de carga diseñados permiten planificar y automatizar la ingestión de los datos provenientes de las fuentes descritas. Por último, la capacidad para utilizar modelos de regresión sobre los datos dota a la arquitectura de la capa necesaria para realizar predicciones y configurar los estudios necesarios. Hemos conseguido crear las bases de un proceso que tiene un gran potencial para monitorizar y proporcionar una adecuada toma de decisiones sobre conceptos agronómicos.</p>
<p>
<figure><img src="figures/completed.png" /><figcaption>Captura de la ejecución del pipeline tras terminar la ejecución por completo.</figcaption>
</figure>
</p>
<p style="page-break-after: always;">&nbsp;</p></div><div id=BIBILIOGRAFÍA><h2>12 BIBILIOGRAFÍA</h2><ul>
<li>Planificación</li>
</ul>
<p>https://www.pmi.org/pmbok-guide-standards/foundational/pmbok#</p>
<p>https://mermaid.js.org/syntax/gantt.html</p>
<p>https://www.pmi.org/learning/library/applying-work-breakdown-structure-project-lifecycle-6979</p>
<ul>
<li>Infraestructura</li>
</ul>
<p>https://en.wikipedia.org/wiki/Infrastructure_as_code</p>
<p>https://www.jenkins.io/</p>
<p>https://www.vagrantup.com/</p>
<ul>
<li>Diseño modelo relacional</li>
</ul>
<p>https://mermaid.js.org/syntax/entityRelationshipDiagram.html</p>
<p>https://docs.djangoproject.com/en/4.1/intro/tutorial01/</p>
<p>https://docs.djangoproject.com/en/4.1/topics/db/queries/</p>
<p>http://gorodinski.com/blog/2012/04/14/services-in-domain-driven-design-ddd/</p>
<p>Domain Driven Design - Eric Evans</p>
<ul>
<li>Automatización Pipeline</li>
</ul>
<p>https://simpleisbetterthancomplex.com/tutorial/2018/08/27/how-to-create-custom-django-management-commands.html</p>
<p>https://medium.com/@bonnotguillaume/software-architecture-the-pipeline-design-pattern-from-zero-to-hero-b5c43d8a4e60</p>
<p>https://www.astera.com/es/type/blog/etl-pipeline-vs-data-pipeline/</p>
<p>https://www.jenkins.io/doc/book/pipeline/syntax/</p>
<ul>
<li>Modelo IA</li>
</ul>
<p>https://stackabuse.com/random-forest-algorithm-with-python-and-scikit-learn/</p>
<p>https://towardsdatascience.com/random-forest-regression-5f605132d19d</p>
<p>https://scikit-learn.org/stable/auto_examples/miscellaneous/plot_pipeline_display.html#sphx-glr-auto-examples-miscellaneous-plot-pipeline-display-py</p>
<p>https://scikit-learn.org/stable/modules/cross_validation.html</p>
<p>https://scikit-learn.org/stable/auto_examples/ensemble/plot_stack_predictors.html#sphx-glr-auto-examples-ensemble-plot-stack-predictors-py</p>
<ul>
<li>Redacción memoria</li>
</ul>
<p>https://networkx.org/</p>
<p>https://github.com/obsidianmd/obsidian-api</p>
<p>https://docs.github.com/en/actions</p></div><p style="page-break-after: always;">&nbsp;</p>

        <div>

    </body>

</html>

